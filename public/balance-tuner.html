<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Tuner</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            margin: 0;
        }
        h1, h2, h3 { color: #ffd700; margin-bottom: 10px; }
        .container { max-width: 1400px; margin: 0 auto; }

        /* Controls Panel */
        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            background: #2a2a4e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-group {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
        }
        .control-group h3 {
            margin-top: 0;
            font-size: 14px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }
        .control-row label {
            flex: 1;
            font-size: 12px;
            color: #aaa;
        }
        .control-row input[type="range"] {
            width: 100px;
        }
        .control-row input[type="number"] {
            width: 70px;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 4px;
            border-radius: 4px;
            text-align: right;
        }
        .control-row select {
            width: 80px;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 4px;
            border-radius: 4px;
        }
        .value-display {
            width: 60px;
            text-align: right;
            font-size: 12px;
            color: #ffd700;
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }
        .btn-primary {
            background: #ffd700;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover { background: #ffed4a; }
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #444;
            color: #eee;
        }
        .btn-secondary:hover { background: #555; }

        /* Status */
        #status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        .status-running { background: #444422; color: #ffd700; }
        .status-done { background: #224422; color: #6bff6b; }
        .status-error { background: #442222; color: #ff6b6b; }

        /* Results */
        .results { display: none; }
        .results.visible { display: block; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        .tab {
            padding: 10px 20px;
            background: #2a2a4e;
            border: none;
            color: #eee;
            cursor: pointer;
            border-radius: 4px;
        }
        .tab.active {
            background: #ffd700;
            color: #1a1a2e;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-size: 12px;
        }
        th, td {
            border: 1px solid #444;
            padding: 6px 10px;
            text-align: right;
        }
        th {
            background: #2a2a4e;
            color: #ffd700;
            position: sticky;
            top: 0;
        }
        tr:nth-child(even) { background: #222244; }
        tr:hover { background: #333366; }
        .table-scroll {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Summary */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .summary-item {
            background: #2a2a4e;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .summary-value {
            font-size: 24px;
            color: #ffd700;
            font-weight: bold;
        }
        .summary-label {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        /* Charts */
        canvas {
            background: #1a1a2e;
            border-radius: 8px;
        }
        .chart-container {
            position: relative;
        }
        .chart-scroll {
            overflow-x: auto;
            max-width: 100%;
        }
        .chart-tooltip {
            position: absolute;
            background: rgba(42, 42, 78, 0.95);
            border: 1px solid #ffd700;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 100;
            white-space: nowrap;
        }
        .chart-tooltip.visible {
            opacity: 1;
        }
        .chart-tooltip .tt-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .chart-tooltip .tt-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        .chart-tooltip .tt-label {
            color: #aaa;
        }
        .chart-tooltip .tt-value {
            font-weight: bold;
        }
        .tt-hero { color: #6bff6b; }
        .tt-enemy { color: #ff6b6b; }
        .tt-diff { color: #ffd700; }
        .tt-loots { color: #6bff6b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Balance Tuner</h1>

        <!-- Controls -->
        <div class="controls-panel">
            <div class="control-group">
                <h3>Item Power</h3>
                <div class="control-row">
                    <label>basePowerPerLevel</label>
                    <input type="range" id="basePowerPerLevel" min="5" max="50" step="1" value="20">
                    <span class="value-display" id="basePowerPerLevel-val">20</span>
                </div>
                <div class="control-row">
                    <label>powerGrowthPerLevel</label>
                    <input type="range" id="powerGrowthPerLevel" min="1.1" max="2.0" step="0.05" value="1.5">
                    <span class="value-display" id="powerGrowthPerLevel-val">1.50</span>
                </div>
                <div class="control-row">
                    <label>powerVariance (±%)</label>
                    <input type="range" id="powerVariance" min="0" max="0.3" step="0.01" value="0.1">
                    <span class="value-display" id="powerVariance-val">10%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Level Range</h3>
                <div class="control-row">
                    <label>minLevelOffset</label>
                    <input type="range" id="minLevelOffset" min="0" max="5" step="1" value="2">
                    <span class="value-display" id="minLevelOffset-val">2</span>
                </div>
                <div class="control-row">
                    <label>maxRarityLevelOffset</label>
                    <input type="range" id="maxRarityLevelOffset" min="0" max="3" step="1" value="1">
                    <span class="value-display" id="maxRarityLevelOffset-val">1</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Guaranteed Upgrade</h3>
                <div class="control-row">
                    <label>Every N loots</label>
                    <input type="range" id="guaranteedUpgradeEveryN" min="0" max="10" step="1" value="4">
                    <span class="value-display" id="guaranteedUpgradeEveryN-val">4</span>
                </div>
                <div class="control-row">
                    <label>+1 every N stages</label>
                    <input type="range" id="guaranteedUpgradeIncreaseEveryNStages" min="0" max="30" step="1" value="10">
                    <span class="value-display" id="guaranteedUpgradeIncreaseEveryNStages-val">10</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Difficulty</h3>
                <div class="control-row">
                    <label>Enabled</label>
                    <input type="checkbox" id="difficultyEnabled" checked>
                    <span class="value-display" id="difficultyEnabled-val">ON</span>
                </div>
                <div class="control-row">
                    <label>On Victory (%)</label>
                    <input type="range" id="difficultyOnVictory" min="0" max="0.05" step="0.005" value="0.01">
                    <span class="value-display" id="difficultyOnVictory-val">+1%</span>
                </div>
                <div class="control-row">
                    <label>On Defeat (%)</label>
                    <input type="range" id="difficultyOnDefeat" min="-0.1" max="0" step="0.005" value="-0.02">
                    <span class="value-display" id="difficultyOnDefeat-val">-2%</span>
                </div>
                <div class="control-row">
                    <label>Boss Multiplier</label>
                    <input type="range" id="bossPowerMultiplier" min="1.0" max="2.0" step="0.05" value="1.1">
                    <span class="value-display" id="bossPowerMultiplier-val">1.10</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Rarity Multipliers</h3>
                <div class="control-row">
                    <label style="color:#9ca3af">Common</label>
                    <input type="number" id="rarity-common" value="1.0" step="0.1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#22c55e">Good</label>
                    <input type="number" id="rarity-good" value="2.5" step="0.1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#3b82f6">Rare</label>
                    <input type="number" id="rarity-rare" value="6.25" step="0.25" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#a855f7">Epic</label>
                    <input type="number" id="rarity-epic" value="15.625" step="0.5" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#f43f5e">Mythic</label>
                    <input type="number" id="rarity-mythic" value="39.0625" step="1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#f59e0b">Legendary</label>
                    <input type="number" id="rarity-legendary" value="97.65625" step="5" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#fbbf24">Immortal</label>
                    <input type="number" id="rarity-immortal" value="244.14" step="10" min="0.1">
                </div>
            </div>

            <div class="control-group">
                <h3>Simulation</h3>
                <div class="control-row">
                    <label>Chapters</label>
                    <input type="number" id="maxChapters" value="20" min="1" max="100">
                </div>
                <div class="control-row">
                    <label>Runs (avg)</label>
                    <select id="simRuns">
                        <option value="1">1</option>
                        <option value="10">10</option>
                        <option value="100">100</option>
                        <option value="1000">1000</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="runBtn" onclick="runSimulation()">Run Simulation</button>
            <button class="btn-secondary" onclick="resetDefaults()">Reset to Defaults</button>
            <button class="btn-secondary" onclick="saveAsDefault()">Save as Default</button>
        </div>

        <div id="status"></div>

        <!-- Results -->
        <div class="results" id="results">
            <div class="summary-grid" id="summary-grid"></div>

            <div class="tabs">
                <button class="tab active" onclick="showTab('charts')">Charts</button>
                <button class="tab" onclick="showTab('chapters')">Chapters</button>
                <button class="tab" onclick="showTab('stages')">Stages</button>
            </div>

            <div id="charts-content" class="tab-content active">
                <h2>Loots per Stage</h2>
                <div class="chart-container chart-scroll">
                    <canvas id="loots-chart" height="250"></canvas>
                    <div class="chart-tooltip" id="loots-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Loots per Chapter</h2>
                <div class="chart-container">
                    <canvas id="loots-chapter-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="loots-chapter-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Lamp Level & Rarity Multiplier</h2>
                <div class="chart-container">
                    <canvas id="lamp-mult-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="lamp-mult-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Loots by Rarity per Chapter</h2>
                <div class="chart-container">
                    <canvas id="rarity-chart" width="1100" height="280"></canvas>
                    <div class="chart-tooltip" id="rarity-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Equipped Rarity per Chapter</h2>
                <div class="chart-container">
                    <canvas id="equipped-chart" width="1100" height="280"></canvas>
                    <div class="chart-tooltip" id="equipped-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Guaranteed Upgrade Interval (EveryN)</h2>
                <div class="chart-container">
                    <canvas id="everyn-chart" width="1100" height="200"></canvas>
                    <div class="chart-tooltip" id="everyn-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Power Progression by Chapter (log scale)</h2>
                <div class="chart-container">
                    <canvas id="power-chart" width="1100" height="350"></canvas>
                    <div class="chart-tooltip" id="power-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Difficulty Modifier %</h2>
                <div class="chart-container">
                    <canvas id="difficulty-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="difficulty-tooltip"></div>
                </div>
            </div>

            <div id="chapters-content" class="tab-content">
                <h2>Chapters Summary</h2>
                <div class="table-scroll" id="chapters-table"></div>
            </div>

            <div id="stages-content" class="tab-content">
                <h2>Stages Detail</h2>
                <div class="table-scroll" id="stages-table"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { runSimulation as runSim, getDefaults } from '/src/testing/BrowserEconomyTester.ts';

        // Rarity colors
        const RARITY_COLORS = {
            common: '#9ca3af',
            good: '#22c55e',
            rare: '#3b82f6',
            epic: '#a855f7',
            mythic: '#f43f5e',
            legendary: '#f59e0b',
            immortal: '#fbbf24'
        };
        const RARITY_ORDER = ['common', 'good', 'rare', 'epic', 'mythic', 'legendary', 'immortal'];

        // Chart data storage for tooltips
        let chartData = {
            power: { chapters: [], padding: {}, xScale: null, yScale: null },
            difficulty: { stages: [], padding: {}, xScale: null, range: 0 },
            loots: { stages: [], padding: {}, barWidth: 0, maxLoots: 0 },
            lootsChapter: { chapters: [], padding: {}, barWidth: 0, maxLoots: 0 },
            lampMult: { chapters: [], stages: [], padding: {}, width: 0, height: 0 },
            rarity: { chapters: [], padding: {}, barWidth: 0 },
            equipped: { chapters: [], padding: {}, barWidth: 0 },
            everyN: { stages: [], padding: {}, width: 0, height: 0 }
        };

        // Make functions available globally
        window.runSimulation = async function() {
            const statusEl = document.getElementById('status');
            const runBtn = document.getElementById('runBtn');
            const numRuns = parseInt(document.getElementById('simRuns').value) || 1;

            statusEl.textContent = numRuns > 1 ? `Running ${numRuns} simulations...` : 'Running simulation...';
            statusEl.className = 'status-running';
            runBtn.disabled = true;

            // Allow UI to update
            await new Promise(r => setTimeout(r, 10));

            try {
                const overrides = getOverridesFromUI();
                const chapters = parseInt(document.getElementById('maxChapters').value) || 20;

                let summary;

                if (numRuns === 1) {
                    summary = runSim(overrides, { maxChapters: chapters, verbose: false });
                } else {
                    const summaries = [];
                    for (let i = 0; i < numRuns; i++) {
                        summaries.push(runSim(overrides, { maxChapters: chapters, verbose: false }));
                        // Update progress every 10 runs or for small counts
                        if (i % Math.max(1, Math.floor(numRuns / 10)) === 0) {
                            statusEl.textContent = `Running... ${i + 1}/${numRuns}`;
                            await new Promise(r => setTimeout(r, 0));
                        }
                    }
                    summary = averageSummaries(summaries);
                }

                renderResults(summary, numRuns);

                const runsText = numRuns > 1 ? ` (avg of ${numRuns} runs)` : '';
                statusEl.textContent = `Done! ${summary.totalChapters} chapters, ${summary.totalLoots} loots, ${summary.totalDefeats} defeats${runsText}`;
                statusEl.className = 'status-done';
            } catch (e) {
                statusEl.textContent = 'Error: ' + e.message;
                statusEl.className = 'status-error';
                console.error(e);
            } finally {
                runBtn.disabled = false;
            }
        };

        // Усреднение результатов нескольких симуляций
        function averageSummaries(summaries) {
            const n = summaries.length;
            const first = summaries[0];

            // Усредняем скаляры
            const avgSummary = {
                totalChapters: Math.round(summaries.reduce((s, r) => s + r.totalChapters, 0) / n),
                totalLoots: Math.round(summaries.reduce((s, r) => s + r.totalLoots, 0) / n),
                totalBattles: Math.round(summaries.reduce((s, r) => s + r.totalBattles, 0) / n),
                totalDefeats: Math.round(summaries.reduce((s, r) => s + r.totalDefeats, 0) / n),
                totalUnfairDefeats: Math.round(summaries.reduce((s, r) => s + r.totalUnfairDefeats, 0) / n),
                totalGoldEarned: Math.round(summaries.reduce((s, r) => s + r.totalGoldEarned, 0) / n),
                totalGoldSpent: Math.round(summaries.reduce((s, r) => s + r.totalGoldSpent, 0) / n),
                finalLampLevel: Math.round(summaries.reduce((s, r) => s + r.finalLampLevel, 0) / n),
                finalHeroPower: Math.round(summaries.reduce((s, r) => s + r.finalHeroPower, 0) / n),
                finalHeroLevel: Math.round(summaries.reduce((s, r) => s + r.finalHeroLevel, 0) / n),
                chapters: [],
                stages: []
            };

            // Усредняем chapters (по индексу)
            const numChapters = Math.min(...summaries.map(s => s.chapters.length));
            for (let i = 0; i < numChapters; i++) {
                // Усредняем lootsByRarity
                const avgLootsByRarity = {};
                for (const rarity of RARITY_ORDER) {
                    avgLootsByRarity[rarity] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].lootsByRarity?.[rarity] || 0), 0) / n);
                }

                // Усредняем equippedByRarity
                const avgEquippedByRarity = {};
                for (const rarity of RARITY_ORDER) {
                    avgEquippedByRarity[rarity] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].equippedByRarity?.[rarity] || 0), 0) / n * 10) / 10;
                }

                avgSummary.chapters.push({
                    chapter: first.chapters[i].chapter,
                    loots: Math.round(summaries.reduce((s, r) => s + r.chapters[i].loots, 0) / n),
                    battles: Math.round(summaries.reduce((s, r) => s + r.chapters[i].battles, 0) / n),
                    defeats: Math.round(summaries.reduce((s, r) => s + r.chapters[i].defeats, 0) / n),
                    unfairDefeats: Math.round(summaries.reduce((s, r) => s + r.chapters[i].unfairDefeats, 0) / n),
                    lampLevel: Math.round(summaries.reduce((s, r) => s + r.chapters[i].lampLevel, 0) / n),
                    heroPower: Math.round(summaries.reduce((s, r) => s + r.chapters[i].heroPower, 0) / n),
                    heroLevel: Math.round(summaries.reduce((s, r) => s + r.chapters[i].heroLevel, 0) / n),
                    goldEarned: Math.round(summaries.reduce((s, r) => s + r.chapters[i].goldEarned, 0) / n),
                    goldSpent: Math.round(summaries.reduce((s, r) => s + r.chapters[i].goldSpent, 0) / n),
                    maxEnemyPower: Math.round(summaries.reduce((s, r) => s + r.chapters[i].maxEnemyPower, 0) / n),
                    lootsByRarity: avgLootsByRarity,
                    equippedByRarity: avgEquippedByRarity
                });
            }

            // Усредняем stages (по индексу)
            const numStages = Math.min(...summaries.map(s => s.stages.length));
            for (let i = 0; i < numStages; i++) {
                avgSummary.stages.push({
                    chapter: first.stages[i].chapter,
                    stage: first.stages[i].stage,
                    loots: Math.round(summaries.reduce((s, r) => s + r.stages[i].loots, 0) / n * 10) / 10,
                    battles: Math.round(summaries.reduce((s, r) => s + r.stages[i].battles, 0) / n * 10) / 10,
                    defeats: Math.round(summaries.reduce((s, r) => s + r.stages[i].defeats, 0) / n * 10) / 10,
                    heroLevel: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroLevel, 0) / n),
                    heroPower: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroPower, 0) / n),
                    heroHp: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroHp, 0) / n),
                    heroDamage: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroDamage, 0) / n),
                    slots: Math.round(summaries.reduce((s, r) => s + r.stages[i].slots, 0) / n),
                    enemyPower: Math.round(summaries.reduce((s, r) => s + r.stages[i].enemyPower, 0) / n),
                    rarityMultiplier: Math.round(summaries.reduce((s, r) => s + r.stages[i].rarityMultiplier, 0) / n * 100) / 100,
                    currentRarityMultiplier: Math.round(summaries.reduce((s, r) => s + (r.stages[i].currentRarityMultiplier || r.stages[i].rarityMultiplier), 0) / n * 100) / 100,
                    difficultyModifier: Math.round(summaries.reduce((s, r) => s + r.stages[i].difficultyModifier, 0) / n),
                    lampLevel: Math.round(summaries.reduce((s, r) => s + r.stages[i].lampLevel, 0) / n),
                    gold: Math.round(summaries.reduce((s, r) => s + r.stages[i].gold, 0) / n),
                    guaranteedEveryN: Math.round(summaries.reduce((s, r) => s + (r.stages[i].guaranteedEveryN || 0), 0) / n)
                });
            }

            return avgSummary;
        }

        window.resetDefaults = function() {
            const defaults = getDefaults();
            applySettings(defaults);
            // Clear saved settings
            localStorage.removeItem('balanceTunerSettings');
            showStatus('Reset to code defaults', 'status-done');
        };

        window.saveAsDefault = function() {
            const settings = getOverridesFromUI();
            settings.maxChapters = parseInt(document.getElementById('maxChapters').value) || 20;
            settings.simRuns = parseInt(document.getElementById('simRuns').value) || 1;
            localStorage.setItem('balanceTunerSettings', JSON.stringify(settings));
            showStatus('Settings saved to browser', 'status-done');
        };

        function loadSavedSettings() {
            const saved = localStorage.getItem('balanceTunerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    applySettings(settings);
                    if (settings.maxChapters) {
                        document.getElementById('maxChapters').value = settings.maxChapters;
                    }
                    if (settings.simRuns) {
                        document.getElementById('simRuns').value = settings.simRuns;
                    }
                } catch (e) {
                    console.warn('Failed to load saved settings:', e);
                }
            }
        }

        function applySettings(settings) {
            setSlider('basePowerPerLevel', settings.basePowerPerLevel);
            setSlider('powerGrowthPerLevel', settings.powerGrowthPerLevel);
            setSlider('powerVariance', settings.powerVariance);
            setSlider('minLevelOffset', settings.minLevelOffset);
            setSlider('maxRarityLevelOffset', settings.maxRarityLevelOffset);
            if (settings.guaranteedUpgradeEveryN !== undefined) {
                setSlider('guaranteedUpgradeEveryN', settings.guaranteedUpgradeEveryN);
            }
            if (settings.guaranteedUpgradeIncreaseEveryNStages !== undefined) {
                setSlider('guaranteedUpgradeIncreaseEveryNStages', settings.guaranteedUpgradeIncreaseEveryNStages);
            }
            if (settings.difficultyEnabled !== undefined) {
                document.getElementById('difficultyEnabled').checked = settings.difficultyEnabled;
                document.getElementById('difficultyEnabled-val').textContent = settings.difficultyEnabled ? 'ON' : 'OFF';
            }
            setSlider('difficultyOnVictory', settings.difficultyOnVictory);
            setSlider('difficultyOnDefeat', settings.difficultyOnDefeat);
            setSlider('bossPowerMultiplier', settings.bossPowerMultiplier);

            if (settings.rarityMultipliers) {
                document.getElementById('rarity-common').value = settings.rarityMultipliers.common;
                document.getElementById('rarity-good').value = settings.rarityMultipliers.good;
                document.getElementById('rarity-rare').value = settings.rarityMultipliers.rare;
                document.getElementById('rarity-epic').value = settings.rarityMultipliers.epic;
                document.getElementById('rarity-mythic').value = settings.rarityMultipliers.mythic;
                document.getElementById('rarity-legendary').value = settings.rarityMultipliers.legendary;
                document.getElementById('rarity-immortal').value = settings.rarityMultipliers.immortal;
            }
        }

        function showStatus(message, className) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = className;
            setTimeout(() => {
                if (statusEl.textContent === message) {
                    statusEl.textContent = '';
                    statusEl.className = '';
                }
            }, 2000);
        }

        window.showTab = function(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(`${tab}-content`).classList.add('active');
        };

        function getOverridesFromUI() {
            return {
                basePowerPerLevel: parseFloat(document.getElementById('basePowerPerLevel').value),
                powerGrowthPerLevel: parseFloat(document.getElementById('powerGrowthPerLevel').value),
                powerVariance: parseFloat(document.getElementById('powerVariance').value),
                minLevelOffset: parseInt(document.getElementById('minLevelOffset').value),
                maxRarityLevelOffset: parseInt(document.getElementById('maxRarityLevelOffset').value),
                guaranteedUpgradeEveryN: parseInt(document.getElementById('guaranteedUpgradeEveryN').value),
                guaranteedUpgradeIncreaseEveryNStages: parseInt(document.getElementById('guaranteedUpgradeIncreaseEveryNStages').value),
                difficultyEnabled: document.getElementById('difficultyEnabled').checked,
                difficultyOnVictory: parseFloat(document.getElementById('difficultyOnVictory').value),
                difficultyOnDefeat: parseFloat(document.getElementById('difficultyOnDefeat').value),
                bossPowerMultiplier: parseFloat(document.getElementById('bossPowerMultiplier').value),
                rarityMultipliers: {
                    common: parseFloat(document.getElementById('rarity-common').value),
                    good: parseFloat(document.getElementById('rarity-good').value),
                    rare: parseFloat(document.getElementById('rarity-rare').value),
                    epic: parseFloat(document.getElementById('rarity-epic').value),
                    mythic: parseFloat(document.getElementById('rarity-mythic').value),
                    legendary: parseFloat(document.getElementById('rarity-legendary').value),
                    immortal: parseFloat(document.getElementById('rarity-immortal').value)
                }
            };
        }

        function setSlider(id, value) {
            const el = document.getElementById(id);
            el.value = value;
            el.dispatchEvent(new Event('input'));
        }

        function renderResults(summary, numRuns = 1) {
            document.getElementById('results').classList.add('visible');

            // Summary grid
            const avgLabel = numRuns > 1 ? ' (avg)' : '';
            const summaryHtml = `
                <div class="summary-item">
                    <div class="summary-value">${summary.totalChapters}</div>
                    <div class="summary-label">Chapters</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalLoots}</div>
                    <div class="summary-label">Total Loots${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalBattles}</div>
                    <div class="summary-label">Battles${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalDefeats}</div>
                    <div class="summary-label">Defeats${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.finalHeroLevel}</div>
                    <div class="summary-label">Final Hero Lvl</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.finalLampLevel}</div>
                    <div class="summary-label">Final Lamp Lvl</div>
                </div>
            `;
            document.getElementById('summary-grid').innerHTML = summaryHtml;

            // Tables
            renderChaptersTable(summary.chapters);
            renderStagesTable(summary.stages);

            // Charts
            renderLootsChart(summary.stages);
            renderLootsChapterChart(summary.chapters);
            renderLampMultChart(summary.chapters, summary.stages);
            renderRarityChart(summary.chapters);
            renderEquippedChart(summary.chapters);
            renderEveryNChart(summary.stages);
            renderPowerChart(summary.chapters);
            renderDifficultyChart(summary.stages);
        }

        function renderChaptersTable(chapters) {
            let html = `<table>
                <tr>
                    <th>Ch</th><th>Loots</th><th>Battles</th><th>Defeats</th>
                    <th>Unfair</th><th>Lamp</th><th>HeroLvl</th><th>Power</th><th>Enemy</th>
                </tr>`;

            for (const c of chapters) {
                html += `<tr>
                    <td>${c.chapter}</td>
                    <td>${c.loots}</td>
                    <td>${c.battles}</td>
                    <td>${c.defeats}</td>
                    <td>${c.unfairDefeats}</td>
                    <td>${c.lampLevel}</td>
                    <td>${c.heroLevel}</td>
                    <td>${c.heroPower}</td>
                    <td>${c.maxEnemyPower}</td>
                </tr>`;
            }

            html += '</table>';
            document.getElementById('chapters-table').innerHTML = html;
        }

        function renderStagesTable(stages) {
            let html = `<table>
                <tr>
                    <th>Ch.St</th><th>Loots</th><th>Defeats</th>
                    <th>HLvl</th><th>Power</th><th>Enemy</th><th>Diff%</th><th>Lamp</th>
                </tr>`;

            for (const s of stages) {
                html += `<tr>
                    <td>${s.chapter}.${s.stage}</td>
                    <td>${s.loots}</td>
                    <td>${s.defeats}</td>
                    <td>${s.heroLevel}</td>
                    <td>${s.heroPower}</td>
                    <td>${s.enemyPower}</td>
                    <td>${s.difficultyModifier >= 0 ? '+' : ''}${s.difficultyModifier}%</td>
                    <td>${s.lampLevel}</td>
                </tr>`;
            }

            html += '</table>';
            document.getElementById('stages-table').innerHTML = html;
        }

        function renderPowerChart(chapters) {
            const canvas = document.getElementById('power-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 40, right: 80, bottom: 60, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const heroPowers = chapters.map(c => c.heroPower);
            const enemyPowers = chapters.map(c => c.maxEnemyPower);
            const maxPower = Math.max(...heroPowers, ...enemyPowers);
            const minPower = Math.min(...heroPowers.filter(p => p > 0), ...enemyPowers.filter(p => p > 0));

            const logMin = Math.log10(Math.max(1, minPower));
            const logMax = Math.log10(maxPower);

            const xScale = (i) => padding.left + (i / Math.max(1, chapters.length - 1)) * width;
            const yScale = (v) => {
                const logV = Math.log10(Math.max(1, v));
                return padding.top + height - ((logV - logMin) / (logMax - logMin)) * height;
            };

            // Save data for tooltip
            chartData.power = { chapters, padding, width, height, xScale };

            // Vertical grid (chapter lines)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + height);
                ctx.stroke();
            }

            // Horizontal grid (power levels)
            for (let p = Math.ceil(logMin); p <= Math.floor(logMax); p++) {
                const y = yScale(Math.pow(10, p));
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();

                ctx.fillStyle = '#888';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'right';
                ctx.fillText(Math.pow(10, p).toLocaleString(), padding.left - 10, y + 4);
            }

            // Hero power line
            ctx.strokeStyle = '#6bff6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(heroPowers[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Hero power points
            ctx.fillStyle = '#6bff6b';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(heroPowers[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Enemy power line
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(enemyPowers[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Enemy power points
            ctx.fillStyle = '#ff6b6b';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(enemyPowers[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Chapter labels on X axis
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                // Show every Nth label to avoid overlap
                if (chapters.length <= 20 || i % Math.ceil(chapters.length / 20) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // X axis label
            ctx.fillText('Chapter', padding.left + width / 2, canvas.height - 10);

            // Legend
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#6bff6b';
            ctx.fillRect(padding.left + 10, padding.top + 10, 12, 12);
            ctx.fillText('Hero Power', padding.left + 30, padding.top + 20);

            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(padding.left + 10, padding.top + 30, 12, 12);
            ctx.fillText('Enemy Power (Boss)', padding.left + 30, padding.top + 40);
        }

        function renderDifficultyChart(stages) {
            const canvas = document.getElementById('difficulty-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const diffMods = stages.map(s => s.difficultyModifier || 0);
            const minDiff = Math.min(...diffMods, -10);
            const maxDiff = Math.max(...diffMods, 10);
            const range = Math.max(Math.abs(minDiff), Math.abs(maxDiff), 20);

            const xScale = (i) => padding.left + (i / (stages.length - 1)) * width;
            const yScale = (v) => padding.top + height / 2 - (v / range) * (height / 2);

            // Save data for tooltip
            chartData.difficulty = { stages, padding, width, height, xScale, range };

            // Zero line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, yScale(0));
            ctx.lineTo(padding.left + width, yScale(0));
            ctx.stroke();

            // Fill
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(0));
            for (let i = 0; i < stages.length; i++) {
                ctx.lineTo(xScale(i), yScale(diffMods[i]));
            }
            ctx.lineTo(xScale(stages.length - 1), yScale(0));
            ctx.closePath();

            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + height);
            gradient.addColorStop(0, '#ff6b6b44');
            gradient.addColorStop(0.5, '#44444444');
            gradient.addColorStop(1, '#6bff6b44');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScale(i);
                const y = yScale(diffMods[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Y labels
            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(`+${Math.round(range)}%`, padding.left - 10, padding.top + 4);
            ctx.fillText('0%', padding.left - 10, yScale(0) + 4);
            ctx.fillText(`${Math.round(-range)}%`, padding.left - 10, padding.top + height + 4);
        }

        function renderLootsChart(stages) {
            const canvas = document.getElementById('loots-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const minBarWidth = 2;  // Минимальная ширина бара
            const minCanvasWidth = 1100;

            // Динамическая ширина canvas
            const neededWidth = padding.left + padding.right + stages.length * minBarWidth;
            canvas.width = Math.max(minCanvasWidth, neededWidth);

            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const loots = stages.map(s => s.loots);
            const maxLoots = Math.max(...loots, 1);

            const barWidth = width / stages.length;

            // Save data for tooltip
            chartData.loots = { stages, padding, width, height, barWidth, maxLoots };

            for (let i = 0; i < stages.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = loots[i] > 0 ? '#6bff6b' : '#333';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Y label
            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);
        }

        function renderLootsChapterChart(chapters) {
            const canvas = document.getElementById('loots-chapter-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const loots = chapters.map(c => c.loots);
            const maxLoots = Math.max(...loots, 1);

            const barWidth = width / chapters.length;

            // Save data for tooltip
            chartData.lootsChapter = { chapters, padding, width, height, barWidth, maxLoots };

            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = '#6bff6b';
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
            }

            // X labels (chapter numbers)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y label
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);
        }

        function renderLampMultChart(chapters, stages) {
            const canvas = document.getElementById('lamp-mult-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0 || stages.length === 0) return;

            // Lamp level data (by chapter)
            const lampLevels = chapters.map(c => c.lampLevel);
            const maxLamp = Math.max(...lampLevels, 31);

            // Multiplier data (by stage)
            const targetValues = stages.map(s => s.rarityMultiplier || 1);
            const currentValues = stages.map(s => s.currentRarityMultiplier || s.rarityMultiplier || 1);
            const maxMult = Math.max(...targetValues, ...currentValues, 2);

            // Scales
            const xScaleChapter = (i) => padding.left + (i / Math.max(1, chapters.length - 1)) * width;
            const xScaleStage = (i) => padding.left + (i / Math.max(1, stages.length - 1)) * width;
            const yScaleLamp = (v) => padding.top + height - (v / maxLamp) * height;
            const yScaleMult = (v) => padding.top + height - ((v - 1) / (maxMult - 1)) * height;

            // Save data for tooltip
            chartData.lampMult = { chapters, stages, padding, width, height, maxLamp, maxMult };

            // Grid (based on lamp levels)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let lvl = 0; lvl <= maxLamp; lvl += 5) {
                const y = yScaleLamp(lvl);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();
            }

            // === Multiplier lines (by stage) ===
            // Target line (dashed gray)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScaleStage(i);
                const y = yScaleMult(targetValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Current multiplier line (cyan)
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScaleStage(i);
                const y = yScaleMult(currentValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // === Lamp level line (by chapter) ===
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                const y = yScaleLamp(lampLevels[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Lamp level points
            ctx.fillStyle = '#ffd700';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                const y = yScaleLamp(lampLevels[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // X labels (chapters)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Left Y axis labels (Lamp Level)
            ctx.textAlign = 'right';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(maxLamp.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Right Y axis labels (Multiplier)
            ctx.textAlign = 'left';
            ctx.fillStyle = '#22d3ee';
            ctx.fillText('×' + maxMult.toFixed(1), padding.left + width + 10, padding.top + 4);
            ctx.fillText('×1.0', padding.left + width + 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendX = padding.left + 10;
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(legendX, padding.top + 5, 12, 3);
            ctx.fillText('Lamp Lvl', legendX + 16, padding.top + 10);
            ctx.fillStyle = '#22d3ee';
            ctx.fillRect(legendX + 80, padding.top + 5, 12, 3);
            ctx.fillText('Mult', legendX + 96, padding.top + 10);
            ctx.fillStyle = '#666';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(legendX + 130, padding.top + 7);
            ctx.lineTo(legendX + 142, padding.top + 7);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillText('Target', legendX + 146, padding.top + 10);
        }

        function renderRarityChart(chapters) {
            const canvas = document.getElementById('rarity-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            // Calculate max total for scaling
            let maxTotal = 0;
            for (const ch of chapters) {
                let total = 0;
                for (const rarity of RARITY_ORDER) {
                    total += ch.lootsByRarity?.[rarity] || 0;
                }
                if (total > maxTotal) maxTotal = total;
            }
            if (maxTotal === 0) maxTotal = 1;

            const barWidth = width / chapters.length;

            // Save data for tooltip
            chartData.rarity = { chapters, padding, width, height, barWidth, maxTotal };

            // Draw stacked bars
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                let yOffset = 0;

                for (const rarity of RARITY_ORDER) {
                    const count = chapters[i].lootsByRarity?.[rarity] || 0;
                    const barHeight = (count / maxTotal) * height;

                    ctx.fillStyle = RARITY_COLORS[rarity];
                    ctx.fillRect(x + 1, padding.top + height - yOffset - barHeight, barWidth - 2, barHeight);

                    yOffset += barHeight;
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels
            ctx.textAlign = 'right';
            ctx.fillText(maxTotal.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendY = padding.top;
            for (const rarity of [...RARITY_ORDER].reverse()) {
                ctx.fillStyle = RARITY_COLORS[rarity];
                ctx.fillRect(padding.left + width + 10, legendY, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(rarity, padding.left + width + 28, legendY + 10);
                legendY += 18;
            }
        }

        function renderEquippedChart(chapters) {
            const canvas = document.getElementById('equipped-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const barWidth = width / chapters.length;

            // Save data for tooltip
            chartData.equipped = { chapters, padding, width, height, barWidth };

            // Draw 100% stacked bars (normalized to total equipped slots)
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const equipped = chapters[i].equippedByRarity || {};

                // Calculate total equipped slots
                let totalSlots = 0;
                for (const rarity of RARITY_ORDER) {
                    totalSlots += equipped[rarity] || 0;
                }
                if (totalSlots === 0) totalSlots = 1;

                let yOffset = 0;
                for (const rarity of RARITY_ORDER) {
                    const count = equipped[rarity] || 0;
                    const barHeight = (count / totalSlots) * height;

                    ctx.fillStyle = RARITY_COLORS[rarity];
                    ctx.fillRect(x + 1, padding.top + height - yOffset - barHeight, barWidth - 2, barHeight);

                    yOffset += barHeight;
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels (percentage)
            ctx.textAlign = 'right';
            ctx.fillText('100%', padding.left - 10, padding.top + 4);
            ctx.fillText('0%', padding.left - 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendY = padding.top;
            for (const rarity of [...RARITY_ORDER].reverse()) {
                ctx.fillStyle = RARITY_COLORS[rarity];
                ctx.fillRect(padding.left + width + 10, legendY, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(rarity, padding.left + width + 28, legendY + 10);
                legendY += 18;
            }
        }

        function renderEveryNChart(stages) {
            const canvas = document.getElementById('everyn-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (stages.length === 0) return;

            const everyNValues = stages.map(s => s.guaranteedEveryN || 0);
            const maxEveryN = Math.max(...everyNValues, 10);

            const xScale = (i) => padding.left + (i / Math.max(1, stages.length - 1)) * width;
            const yScale = (v) => padding.top + height - (v / maxEveryN) * height;

            // Save data for tooltip
            chartData.everyN = { stages, padding, width, height, xScale, yScale, maxEveryN };

            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let v = 0; v <= maxEveryN; v += 2) {
                const y = yScale(v);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();
            }

            // Fill area
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(0));
            for (let i = 0; i < stages.length; i++) {
                ctx.lineTo(xScale(i), yScale(everyNValues[i]));
            }
            ctx.lineTo(xScale(stages.length - 1), yScale(0));
            ctx.closePath();
            ctx.fillStyle = '#ffd70033';
            ctx.fill();

            // Line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScale(i);
                const y = yScale(everyNValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Y labels
            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(maxEveryN.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);
        }

        // Initialize sliders with value display
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            const valEl = document.getElementById(slider.id + '-val');
            if (!valEl) return;

            slider.addEventListener('input', () => {
                const v = parseFloat(slider.value);
                if (slider.id === 'powerVariance') {
                    valEl.textContent = Math.round(v * 100) + '%';
                } else if (slider.id.includes('difficulty')) {
                    valEl.textContent = (v >= 0 ? '+' : '') + Math.round(v * 100) + '%';
                } else if (slider.id === 'powerGrowthPerLevel' || slider.id === 'bossPowerMultiplier') {
                    valEl.textContent = v.toFixed(2);
                } else {
                    valEl.textContent = v;
                }
            });

            // Trigger initial display
            slider.dispatchEvent(new Event('input'));
        });

        // Checkbox handler for difficultyEnabled
        const difficultyCheckbox = document.getElementById('difficultyEnabled');
        difficultyCheckbox.addEventListener('change', () => {
            document.getElementById('difficultyEnabled-val').textContent = difficultyCheckbox.checked ? 'ON' : 'OFF';
        });

        // Load saved settings on page load
        loadSavedSettings();

        // Tooltip handlers for Power chart
        const powerCanvas = document.getElementById('power-chart');
        const powerTooltip = document.getElementById('power-tooltip');

        powerCanvas.addEventListener('mousemove', (e) => {
            const rect = powerCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.power;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, width } = data;

            // Find closest chapter
            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                powerTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (chapters.length - 1));
            if (idx < 0 || idx >= chapters.length) {
                powerTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            powerTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${ch.heroPower.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Enemy Power:</span> <span class="tt-value tt-enemy">${ch.maxEnemyPower.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value">${ch.loots}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${ch.defeats}</span></div>
            `;

            // Position tooltip
            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            powerTooltip.style.left = left + 'px';
            powerTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            powerTooltip.classList.add('visible');
        });

        powerCanvas.addEventListener('mouseleave', () => {
            powerTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Difficulty chart
        const diffCanvas = document.getElementById('difficulty-chart');
        const diffTooltip = document.getElementById('difficulty-tooltip');

        diffCanvas.addEventListener('mousemove', (e) => {
            const rect = diffCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.difficulty;

            if (!data.stages || data.stages.length === 0) return;

            const { stages, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                diffTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (stages.length - 1));
            if (idx < 0 || idx >= stages.length) {
                diffTooltip.classList.remove('visible');
                return;
            }

            const st = stages[idx];
            const diffSign = st.difficultyModifier >= 0 ? '+' : '';
            diffTooltip.innerHTML = `
                <div class="tt-title">Stage ${st.chapter}.${st.stage}</div>
                <div class="tt-row"><span class="tt-label">Difficulty:</span> <span class="tt-value tt-diff">${diffSign}${st.difficultyModifier}%</span></div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${st.heroPower.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Enemy Power:</span> <span class="tt-value tt-enemy">${st.enemyPower.toLocaleString()}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            diffTooltip.style.left = left + 'px';
            diffTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            diffTooltip.classList.add('visible');
        });

        diffCanvas.addEventListener('mouseleave', () => {
            diffTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Loots chart
        const lootsCanvas = document.getElementById('loots-chart');
        const lootsTooltip = document.getElementById('loots-tooltip');

        lootsCanvas.addEventListener('mousemove', (e) => {
            const rect = lootsCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.loots;

            if (!data.stages || data.stages.length === 0) return;

            const { stages, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * stages.length) {
                lootsTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= stages.length) {
                lootsTooltip.classList.remove('visible');
                return;
            }

            const st = stages[idx];
            lootsTooltip.innerHTML = `
                <div class="tt-title">Stage ${st.chapter}.${st.stage}</div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value tt-loots">${st.loots}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${st.defeats}</span></div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${st.heroPower.toLocaleString()}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            lootsTooltip.style.left = left + 'px';
            lootsTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lootsTooltip.classList.add('visible');
        });

        lootsCanvas.addEventListener('mouseleave', () => {
            lootsTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Loots Chapter chart
        const lootsChapterCanvas = document.getElementById('loots-chapter-chart');
        const lootsChapterTooltip = document.getElementById('loots-chapter-tooltip');

        lootsChapterCanvas.addEventListener('mousemove', (e) => {
            const rect = lootsChapterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.lootsChapter;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                lootsChapterTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                lootsChapterTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            lootsChapterTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value tt-loots">${ch.loots}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${ch.defeats}</span></div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${ch.heroPower.toLocaleString()}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            lootsChapterTooltip.style.left = left + 'px';
            lootsChapterTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lootsChapterTooltip.classList.add('visible');
        });

        lootsChapterCanvas.addEventListener('mouseleave', () => {
            lootsChapterTooltip.classList.remove('visible');
        });

        // Tooltip handlers for combined Lamp & Multiplier chart
        const lampMultCanvas = document.getElementById('lamp-mult-chart');
        const lampMultTooltip = document.getElementById('lamp-mult-tooltip');

        lampMultCanvas.addEventListener('mousemove', (e) => {
            const rect = lampMultCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.lampMult;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, stages, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                lampMultTooltip.classList.remove('visible');
                return;
            }

            // Find chapter by x position
            const chapterIdx = Math.round((relX / width) * (chapters.length - 1));
            if (chapterIdx < 0 || chapterIdx >= chapters.length) {
                lampMultTooltip.classList.remove('visible');
                return;
            }

            // Find corresponding stage for multiplier data
            const stageIdx = Math.round((relX / width) * (stages.length - 1));
            const ch = chapters[chapterIdx];
            const st = stages[Math.min(stageIdx, stages.length - 1)];

            const current = st?.currentRarityMultiplier || st?.rarityMultiplier || 1;
            const target = st?.rarityMultiplier || 1;

            lampMultTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Lamp Level:</span> <span class="tt-value" style="color:#ffd700">${ch.lampLevel}</span></div>
                <div class="tt-row"><span class="tt-label">Gold Spent:</span> <span class="tt-value">${ch.goldSpent.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Current Mult:</span> <span class="tt-value" style="color:#22d3ee">×${current.toFixed(2)}</span></div>
                <div class="tt-row"><span class="tt-label">Target Mult:</span> <span class="tt-value">×${target.toFixed(2)}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 170 > rect.width) left = e.clientX - rect.left - 170;
            lampMultTooltip.style.left = left + 'px';
            lampMultTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lampMultTooltip.classList.add('visible');
        });

        lampMultCanvas.addEventListener('mouseleave', () => {
            lampMultTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Rarity chart
        const rarityCanvas = document.getElementById('rarity-chart');
        const rarityTooltip = document.getElementById('rarity-tooltip');

        rarityCanvas.addEventListener('mousemove', (e) => {
            const rect = rarityCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.rarity;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                rarityTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                rarityTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const rarityRows = RARITY_ORDER.map(r => {
                const count = ch.lootsByRarity?.[r] || 0;
                return count > 0 ? `<div class="tt-row"><span class="tt-label" style="color:${RARITY_COLORS[r]}">${r}:</span> <span class="tt-value">${count}</span></div>` : '';
            }).join('');

            rarityTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                ${rarityRows}
                <div class="tt-row"><span class="tt-label">Total:</span> <span class="tt-value tt-loots">${ch.loots}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            rarityTooltip.style.left = left + 'px';
            rarityTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            rarityTooltip.classList.add('visible');
        });

        rarityCanvas.addEventListener('mouseleave', () => {
            rarityTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Equipped chart
        const equippedCanvas = document.getElementById('equipped-chart');
        const equippedTooltip = document.getElementById('equipped-tooltip');

        equippedCanvas.addEventListener('mousemove', (e) => {
            const rect = equippedCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.equipped;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                equippedTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                equippedTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const equipped = ch.equippedByRarity || {};

            // Calculate total and percentages
            let totalSlots = 0;
            for (const r of RARITY_ORDER) {
                totalSlots += equipped[r] || 0;
            }

            const equippedRows = RARITY_ORDER.map(r => {
                const count = equipped[r] || 0;
                const pct = totalSlots > 0 ? Math.round(count / totalSlots * 100) : 0;
                return count > 0 ? `<div class="tt-row"><span class="tt-label" style="color:${RARITY_COLORS[r]}">${r}:</span> <span class="tt-value">${count} (${pct}%)</span></div>` : '';
            }).join('');

            equippedTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                ${equippedRows}
                <div class="tt-row"><span class="tt-label">Total slots:</span> <span class="tt-value">${totalSlots}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            equippedTooltip.style.left = left + 'px';
            equippedTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            equippedTooltip.classList.add('visible');
        });

        equippedCanvas.addEventListener('mouseleave', () => {
            equippedTooltip.classList.remove('visible');
        });

        // Tooltip handlers for EveryN chart
        const everyNCanvas = document.getElementById('everyn-chart');
        const everyNTooltip = document.getElementById('everyn-tooltip');

        everyNCanvas.addEventListener('mousemove', (e) => {
            const rect = everyNCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.everyN;

            if (!data.stages || data.stages.length === 0) return;

            const { stages, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                everyNTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (stages.length - 1));
            if (idx < 0 || idx >= stages.length) {
                everyNTooltip.classList.remove('visible');
                return;
            }

            const st = stages[idx];
            everyNTooltip.innerHTML = `
                <div class="tt-title">Stage ${st.chapter}.${st.stage}</div>
                <div class="tt-row"><span class="tt-label">EveryN:</span> <span class="tt-value tt-diff">${st.guaranteedEveryN}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 140 > rect.width) left = e.clientX - rect.left - 140;
            everyNTooltip.style.left = left + 'px';
            everyNTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            everyNTooltip.classList.add('visible');
        });

        everyNCanvas.addEventListener('mouseleave', () => {
            everyNTooltip.classList.remove('visible');
        });
    </script>
</body>
</html>
