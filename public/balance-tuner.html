<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Tuner (Updated: 01-16 20:45)</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            margin: 0;
        }
        h1, h2, h3 { color: #ffd700; margin-bottom: 10px; }
        .container { max-width: 1400px; margin: 0 auto; }

        /* Controls Panel */
        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            background: #2a2a4e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-group {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
        }
        .control-group h3 {
            margin-top: 0;
            font-size: 14px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }
        .control-row label {
            flex: 1;
            font-size: 12px;
            color: #aaa;
        }
        .control-row input[type="range"] {
            width: 100px;
        }
        .control-row input[type="number"] {
            width: 70px;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 4px;
            border-radius: 4px;
            text-align: right;
        }
        .control-row select {
            width: 80px;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 4px;
            border-radius: 4px;
        }
        .value-display {
            width: 60px;
            text-align: right;
            font-size: 12px;
            color: #ffd700;
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }
        .btn-primary {
            background: #ffd700;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover { background: #ffed4a; }
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #444;
            color: #eee;
        }
        .btn-secondary:hover { background: #555; }

        /* Status */
        #status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        .status-running { background: #444422; color: #ffd700; }
        .status-done { background: #224422; color: #6bff6b; }
        .status-error { background: #442222; color: #ff6b6b; }

        /* Results */
        .results { display: none; }
        .results.visible { display: block; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        .tab {
            padding: 10px 20px;
            background: #2a2a4e;
            border: none;
            color: #eee;
            cursor: pointer;
            border-radius: 4px;
        }
        .tab.active {
            background: #ffd700;
            color: #1a1a2e;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-size: 12px;
        }
        th, td {
            border: 1px solid #444;
            padding: 6px 10px;
            text-align: right;
        }
        th {
            background: #2a2a4e;
            color: #ffd700;
            position: sticky;
            top: 0;
        }
        tr:nth-child(even) { background: #222244; }
        tr:hover { background: #333366; }
        .table-scroll {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Summary */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .summary-item {
            background: #2a2a4e;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .summary-value {
            font-size: 24px;
            color: #ffd700;
            font-weight: bold;
        }
        .summary-label {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        /* Charts */
        canvas {
            background: #1a1a2e;
            border-radius: 8px;
        }
        .chart-container {
            position: relative;
        }
        .chart-scroll {
            overflow-x: auto;
            max-width: 100%;
        }
        .chart-tooltip {
            position: absolute;
            background: rgba(42, 42, 78, 0.95);
            border: 1px solid #ffd700;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 100;
            white-space: nowrap;
        }
        .chart-tooltip.visible {
            opacity: 1;
        }
        .chart-tooltip .tt-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .chart-tooltip .tt-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        .chart-tooltip .tt-label {
            color: #aaa;
        }
        .chart-tooltip .tt-value {
            font-weight: bold;
        }
        .tt-hero { color: #6bff6b; }
        .tt-enemy { color: #ff6b6b; }
        .tt-diff { color: #ffd700; }
        .tt-loots { color: #6bff6b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Balance Tuner <span style="font-size: 14px; color: #888; font-weight: normal;">(Updated: 01-16 19:45)</span></h1>

        <!-- Controls -->
        <div class="controls-panel">
            <div class="control-group">
                <h3>Item Power</h3>
                <div class="control-row">
                    <label>basePowerPerLevel</label>
                    <input type="range" id="basePowerPerLevel" min="5" max="50" step="1" value="20">
                    <span class="value-display" id="basePowerPerLevel-val">20</span>
                </div>
                <div class="control-row">
                    <label>powerGrowthPerLevel</label>
                    <input type="range" id="powerGrowthPerLevel" min="1.1" max="2.0" step="0.05" value="1.5">
                    <span class="value-display" id="powerGrowthPerLevel-val">1.50</span>
                </div>
                <div class="control-row">
                    <label>powerVariance (±%)</label>
                    <input type="range" id="powerVariance" min="0" max="0.3" step="0.01" value="0.1">
                    <span class="value-display" id="powerVariance-val">10%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Level Range</h3>
                <div class="control-row">
                    <label>minLevelOffset</label>
                    <input type="range" id="minLevelOffset" min="0" max="5" step="1" value="2">
                    <span class="value-display" id="minLevelOffset-val">2</span>
                </div>
                <div class="control-row">
                    <label>maxRarityLevelOffset</label>
                    <input type="range" id="maxRarityLevelOffset" min="0" max="3" step="1" value="1">
                    <span class="value-display" id="maxRarityLevelOffset-val">1</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Guaranteed Upgrade</h3>
                <div class="control-row">
                    <label>Every N loots</label>
                    <input type="range" id="guaranteedUpgradeEveryN" min="0" max="10" step="1" value="4">
                    <span class="value-display" id="guaranteedUpgradeEveryN-val">4</span>
                </div>
                <div class="control-row">
                    <label>+1 every N stages</label>
                    <input type="range" id="guaranteedUpgradeIncreaseEveryNStages" min="0" max="30" step="1" value="10">
                    <span class="value-display" id="guaranteedUpgradeIncreaseEveryNStages-val">10</span>
                </div>
                <div class="control-row">
                    <label>Rarity Guarantee</label>
                    <input type="checkbox" id="guaranteedRarityEnabled" checked>
                    <span class="value-display" id="guaranteedRarityEnabled-val">ON</span>
                </div>
                <div class="control-row">
                    <label>Rarity Interval ×</label>
                    <input type="range" id="guaranteedRarityIntervalMultiplier" min="0" max="5" step="0.1" value="1">
                    <span class="value-display" id="guaranteedRarityIntervalMultiplier-val">1.0</span>
                </div>
                <div class="control-row">
                    <label>Rarity Level Offset</label>
                    <input type="range" id="guaranteedRarityLevelOffset" min="-5" max="0" step="1" value="0">
                    <span class="value-display" id="guaranteedRarityLevelOffset-val">0 (max)</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Boss</h3>
                <div class="control-row">
                    <label>Boss Multiplier</label>
                    <input type="range" id="bossPowerMultiplier" min="1.0" max="2.0" step="0.05" value="1.1">
                    <span class="value-display" id="bossPowerMultiplier-val">1.10</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Enemy Scaling</h3>
                <div class="control-row">
                    <label>minProbForGradualGrowth</label>
                    <input type="range" id="minProbForGradualGrowth" min="0" max="0.05" step="0.001" value="0.015">
                    <span class="value-display" id="minProbForGradualGrowth-val">1.50%</span>
                </div>
                <div class="control-row">
                    <label>stepsToTarget</label>
                    <input type="range" id="stepsToTarget" min="10" max="100" step="5" value="40">
                    <span class="value-display" id="stepsToTarget-val">40</span>
                </div>
                <div class="control-row">
                    <label>baseDropsForMultiplier</label>
                    <input type="range" id="baseDropsForMultiplier" min="5" max="30" step="1" value="10">
                    <span class="value-display" id="baseDropsForMultiplier-val">10</span>
                </div>
                <div class="control-row">
                    <label>dropsPerChapter</label>
                    <input type="range" id="dropsPerChapter" min="0" max="5" step="0.5" value="2">
                    <span class="value-display" id="dropsPerChapter-val">2</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Rarity Multipliers</h3>
                <div class="control-row">
                    <label style="color:#9ca3af">Common</label>
                    <input type="number" id="rarity-common" value="1.0" step="0.1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#22c55e">Good</label>
                    <input type="number" id="rarity-good" value="2.5" step="0.1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#3b82f6">Rare</label>
                    <input type="number" id="rarity-rare" value="6.25" step="0.25" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#a855f7">Epic</label>
                    <input type="number" id="rarity-epic" value="15.625" step="0.5" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#f43f5e">Mythic</label>
                    <input type="number" id="rarity-mythic" value="39.0625" step="1" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#f59e0b">Legendary</label>
                    <input type="number" id="rarity-legendary" value="97.65625" step="5" min="0.1">
                </div>
                <div class="control-row">
                    <label style="color:#fbbf24">Immortal</label>
                    <input type="number" id="rarity-immortal" value="244.14" step="10" min="0.1">
                </div>
            </div>

            <div class="control-group">
                <h3>Simulation</h3>
                <div class="control-row">
                    <label>Chapters</label>
                    <input type="number" id="maxChapters" value="20" min="1" max="100">
                </div>
                <div class="control-row">
                    <label>Runs (avg)</label>
                    <select id="simRuns">
                        <option value="1">1</option>
                        <option value="10">10</option>
                        <option value="100">100</option>
                        <option value="1000">1000</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="runBtn" onclick="runSimulation()">Run Simulation</button>
            <button class="btn-secondary" onclick="resetDefaults()">Reset to Defaults</button>
            <button class="btn-secondary" onclick="saveAsDefault()">Save as Default</button>
        </div>

        <div id="status"></div>

        <!-- Results -->
        <div class="results" id="results">
            <div class="summary-grid" id="summary-grid"></div>

            <div class="tabs">
                <button class="tab active" onclick="showTab('charts')">Charts</button>
                <button class="tab" onclick="showTab('chapters')">Chapters</button>
                <button class="tab" onclick="showTab('stages')">Stages</button>
            </div>

            <div id="charts-content" class="tab-content active">
                <h2>Loots per Stage & Guaranteed Upgrade Interval</h2>
                <div class="chart-container chart-scroll">
                    <canvas id="loots-chart" height="250"></canvas>
                    <div class="chart-tooltip" id="loots-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Loots per Chapter</h2>
                <div class="chart-container">
                    <canvas id="loots-chapter-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="loots-chapter-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Lamp Level & Rarity Multiplier</h2>
                <div class="chart-container">
                    <canvas id="lamp-mult-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="lamp-mult-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Loots by Rarity per Chapter</h2>
                <div class="chart-container">
                    <canvas id="rarity-chart" width="1100" height="280"></canvas>
                    <div class="chart-tooltip" id="rarity-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Equipped Rarity per Chapter</h2>
                <div class="chart-container">
                    <canvas id="equipped-chart" width="1100" height="280"></canvas>
                    <div class="chart-tooltip" id="equipped-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Expected Rarity per Chapter (Coupon Collector)</h2>
                <div class="chart-container">
                    <canvas id="expected-rarity-chart" width="1100" height="280"></canvas>
                    <div class="chart-tooltip" id="expected-rarity-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Item Level: Expected vs Actual</h2>
                <div class="chart-container">
                    <canvas id="item-level-chart" width="1100" height="250"></canvas>
                    <div class="chart-tooltip" id="item-level-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Unfair Battles by Enemy Count</h2>
                <div class="chart-container">
                    <canvas id="unfair-chart" width="1100" height="300"></canvas>
                    <div class="chart-tooltip" id="unfair-tooltip"></div>
                </div>

                <h2 style="margin-top: 30px;">Power Progression by Chapter (log scale)</h2>
                <div class="chart-container">
                    <canvas id="power-chart" width="1100" height="350"></canvas>
                    <div class="chart-tooltip" id="power-tooltip"></div>
                </div>

            </div>

            <div id="chapters-content" class="tab-content">
                <h2>Chapters Summary</h2>
                <div class="table-scroll" id="chapters-table"></div>
            </div>

            <div id="stages-content" class="tab-content">
                <h2>Stages Detail</h2>
                <div class="table-scroll" id="stages-table"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { runSimulation as runSim, getDefaults } from '../src/testing/BrowserEconomyTester.ts';

        // Rarity colors
        const RARITY_COLORS = {
            common: '#9ca3af',
            good: '#22c55e',
            rare: '#3b82f6',
            epic: '#a855f7',
            mythic: '#f43f5e',
            legendary: '#f59e0b',
            immortal: '#fbbf24'
        };
        const RARITY_ORDER = ['common', 'good', 'rare', 'epic', 'mythic', 'legendary', 'immortal'];

        // Chart data storage for tooltips
        let chartData = {
            power: { chapters: [], padding: {}, xScale: null, yScale: null },
            loots: { stages: [], padding: {}, barWidth: 0, maxLoots: 0 },
            lootsChapter: { chapters: [], padding: {}, barWidth: 0, maxLoots: 0 },
            lampMult: { chapters: [], stages: [], padding: {}, width: 0, height: 0 },
            rarity: { chapters: [], padding: {}, barWidth: 0 },
            equipped: { chapters: [], padding: {}, barWidth: 0 },
            expectedRarity: { stages: [], padding: {}, barWidth: 0 },
            everyN: { stages: [], padding: {}, width: 0, height: 0 },
            itemLevel: { chapters: [], padding: {}, width: 0, height: 0 },
            unfair: { chapters: [], padding: {}, width: 0, height: 0 }
        };

        // Make functions available globally
        window.runSimulation = async function() {
            const statusEl = document.getElementById('status');
            const runBtn = document.getElementById('runBtn');
            const numRuns = parseInt(document.getElementById('simRuns').value) || 1;

            statusEl.textContent = numRuns > 1 ? `Running ${numRuns} simulations...` : 'Running simulation...';
            statusEl.className = 'status-running';
            runBtn.disabled = true;

            // Allow UI to update
            await new Promise(r => setTimeout(r, 10));

            try {
                const overrides = getOverridesFromUI();
                const chapters = parseInt(document.getElementById('maxChapters').value) || 20;

                let summary;

                if (numRuns === 1) {
                    summary = runSim(overrides, { maxChapters: chapters, verbose: false });
                } else {
                    const summaries = [];
                    for (let i = 0; i < numRuns; i++) {
                        summaries.push(runSim(overrides, { maxChapters: chapters, verbose: false }));
                        // Update progress every 10 runs or for small counts
                        if (i % Math.max(1, Math.floor(numRuns / 10)) === 0) {
                            statusEl.textContent = `Running... ${i + 1}/${numRuns}`;
                            await new Promise(r => setTimeout(r, 0));
                        }
                    }
                    summary = averageSummaries(summaries);
                }

                renderResults(summary, numRuns);

                const runsText = numRuns > 1 ? ` (avg of ${numRuns} runs)` : '';
                statusEl.textContent = `Done! ${summary.totalChapters} chapters, ${summary.totalLoots} loots, ${summary.totalDefeats} defeats${runsText}`;
                statusEl.className = 'status-done';
            } catch (e) {
                statusEl.textContent = 'Error: ' + e.message;
                statusEl.className = 'status-error';
                console.error(e);
            } finally {
                runBtn.disabled = false;
            }
        };

        // Усреднение результатов нескольких симуляций
        function averageSummaries(summaries) {
            const n = summaries.length;
            const first = summaries[0];

            // Вычисляем max loots per stage и per chapter для каждой симуляции
            const maxLootsPerStageValues = summaries.map(s => Math.max(...s.stages.map(st => st.loots)));
            const maxLootsPerChapterValues = summaries.map(s => Math.max(...s.chapters.map(ch => ch.loots)));

            // Вычисляем среднее и стандартное отклонение
            const avgMaxLootsPerStage = maxLootsPerStageValues.reduce((a, b) => a + b, 0) / n;
            const avgMaxLootsPerChapter = maxLootsPerChapterValues.reduce((a, b) => a + b, 0) / n;

            const stdMaxLootsPerStage = Math.sqrt(
                maxLootsPerStageValues.reduce((sum, v) => sum + Math.pow(v - avgMaxLootsPerStage, 2), 0) / n
            );
            const stdMaxLootsPerChapter = Math.sqrt(
                maxLootsPerChapterValues.reduce((sum, v) => sum + Math.pow(v - avgMaxLootsPerChapter, 2), 0) / n
            );

            // Min/Max для диапазона
            const minMaxLootsPerStage = Math.min(...maxLootsPerStageValues);
            const maxMaxLootsPerStage = Math.max(...maxLootsPerStageValues);
            const minMaxLootsPerChapter = Math.min(...maxLootsPerChapterValues);
            const maxMaxLootsPerChapter = Math.max(...maxLootsPerChapterValues);

            // Усредняем скаляры
            const avgSummary = {
                totalChapters: Math.round(summaries.reduce((s, r) => s + r.totalChapters, 0) / n),
                totalLoots: Math.round(summaries.reduce((s, r) => s + r.totalLoots, 0) / n),
                totalBattles: Math.round(summaries.reduce((s, r) => s + r.totalBattles, 0) / n),
                totalDefeats: Math.round(summaries.reduce((s, r) => s + r.totalDefeats, 0) / n),
                totalUnfairDefeats: Math.round(summaries.reduce((s, r) => s + r.totalUnfairDefeats, 0) / n),
                totalGoldEarned: Math.round(summaries.reduce((s, r) => s + r.totalGoldEarned, 0) / n),
                totalGoldSpent: Math.round(summaries.reduce((s, r) => s + r.totalGoldSpent, 0) / n),
                finalLampLevel: Math.round(summaries.reduce((s, r) => s + r.finalLampLevel, 0) / n),
                finalHeroPower: Math.round(summaries.reduce((s, r) => s + r.finalHeroPower, 0) / n),
                finalHeroLevel: Math.round(summaries.reduce((s, r) => s + r.finalHeroLevel, 0) / n),
                chapters: [],
                stages: [],
                // Статистика дисперсии max loots
                varianceStats: {
                    maxLootsPerStage: {
                        avg: Math.round(avgMaxLootsPerStage * 10) / 10,
                        std: Math.round(stdMaxLootsPerStage * 10) / 10,
                        min: minMaxLootsPerStage,
                        max: maxMaxLootsPerStage
                    },
                    maxLootsPerChapter: {
                        avg: Math.round(avgMaxLootsPerChapter * 10) / 10,
                        std: Math.round(stdMaxLootsPerChapter * 10) / 10,
                        min: minMaxLootsPerChapter,
                        max: maxMaxLootsPerChapter
                    }
                }
            };

            // Усредняем chapters (по индексу)
            const numChapters = Math.min(...summaries.map(s => s.chapters.length));
            for (let i = 0; i < numChapters; i++) {
                // Усредняем lootsByRarity
                const avgLootsByRarity = {};
                for (const rarity of RARITY_ORDER) {
                    avgLootsByRarity[rarity] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].lootsByRarity?.[rarity] || 0), 0) / n);
                }

                // Усредняем equippedByRarity
                const avgEquippedByRarity = {};
                for (const rarity of RARITY_ORDER) {
                    avgEquippedByRarity[rarity] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].equippedByRarity?.[rarity] || 0), 0) / n * 10) / 10;
                }

                // Усредняем unfairStats
                const avgUnfairStats = {
                    wins: [0, 0, 0],
                    losses: [0, 0, 0],
                    total: [0, 0, 0]
                };
                for (let j = 0; j < 3; j++) {
                    avgUnfairStats.wins[j] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].unfairStats?.wins[j] || 0), 0) / n * 10) / 10;
                    avgUnfairStats.losses[j] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].unfairStats?.losses[j] || 0), 0) / n * 10) / 10;
                    avgUnfairStats.total[j] = Math.round(summaries.reduce((s, r) => s + (r.chapters[i].unfairStats?.total[j] || 0), 0) / n * 10) / 10;
                }

                avgSummary.chapters.push({
                    chapter: first.chapters[i].chapter,
                    loots: Math.round(summaries.reduce((s, r) => s + r.chapters[i].loots, 0) / n),
                    battles: Math.round(summaries.reduce((s, r) => s + r.chapters[i].battles, 0) / n),
                    defeats: Math.round(summaries.reduce((s, r) => s + r.chapters[i].defeats, 0) / n),
                    unfairDefeats: Math.round(summaries.reduce((s, r) => s + r.chapters[i].unfairDefeats, 0) / n),
                    unfairStats: avgUnfairStats,
                    lampLevel: Math.round(summaries.reduce((s, r) => s + r.chapters[i].lampLevel, 0) / n),
                    heroPower: Math.round(summaries.reduce((s, r) => s + r.chapters[i].heroPower, 0) / n),
                    heroLevel: Math.round(summaries.reduce((s, r) => s + r.chapters[i].heroLevel, 0) / n),
                    goldEarned: Math.round(summaries.reduce((s, r) => s + r.chapters[i].goldEarned, 0) / n),
                    goldSpent: Math.round(summaries.reduce((s, r) => s + r.chapters[i].goldSpent, 0) / n),
                    maxEnemyPower: Math.round(summaries.reduce((s, r) => s + r.chapters[i].maxEnemyPower, 0) / n),
                    lootsByRarity: avgLootsByRarity,
                    equippedByRarity: avgEquippedByRarity,
                    avgItemLevel: Math.round(summaries.reduce((s, r) => s + (r.chapters[i].avgItemLevel || 0), 0) / n * 10) / 10
                });
            }

            // Усредняем stages (по индексу)
            const numStages = Math.min(...summaries.map(s => s.stages.length));
            for (let i = 0; i < numStages; i++) {
                avgSummary.stages.push({
                    chapter: first.stages[i].chapter,
                    stage: first.stages[i].stage,
                    loots: Math.round(summaries.reduce((s, r) => s + r.stages[i].loots, 0) / n * 10) / 10,
                    battles: Math.round(summaries.reduce((s, r) => s + r.stages[i].battles, 0) / n * 10) / 10,
                    defeats: Math.round(summaries.reduce((s, r) => s + r.stages[i].defeats, 0) / n * 10) / 10,
                    heroLevel: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroLevel, 0) / n),
                    heroPower: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroPower, 0) / n),
                    heroHp: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroHp, 0) / n),
                    heroDamage: Math.round(summaries.reduce((s, r) => s + r.stages[i].heroDamage, 0) / n),
                    slots: Math.round(summaries.reduce((s, r) => s + r.stages[i].slots, 0) / n),
                    enemyPower: Math.round(summaries.reduce((s, r) => s + r.stages[i].enemyPower, 0) / n),
                    rarityMultiplier: Math.round(summaries.reduce((s, r) => s + r.stages[i].rarityMultiplier, 0) / n * 100) / 100,
                    currentRarityMultiplier: Math.round(summaries.reduce((s, r) => s + (r.stages[i].currentRarityMultiplier || r.stages[i].rarityMultiplier), 0) / n * 100) / 100,
                    lampLevel: Math.round(summaries.reduce((s, r) => s + r.stages[i].lampLevel, 0) / n),
                    gold: Math.round(summaries.reduce((s, r) => s + r.stages[i].gold, 0) / n),
                    guaranteedEveryN: Math.round(summaries.reduce((s, r) => s + (r.stages[i].guaranteedEveryN || 0), 0) / n),
                    guaranteedRarity: first.stages[i].guaranteedRarity || 'common',  // берём из первой симуляции
                    rarityInterval: Math.round(summaries.reduce((s, r) => s + (r.stages[i].rarityInterval || 0), 0) / n * 10) / 10,
                    totalDrops: Math.round(summaries.reduce((s, r) => s + (r.stages[i].totalDrops || 0), 0) / n * 10) / 10
                });
            }

            return avgSummary;
        }

        window.resetDefaults = function() {
            const defaults = getDefaults();
            applySettings(defaults);
            // Clear saved settings
            localStorage.removeItem('balanceTunerSettings');
            showStatus('Reset to code defaults', 'status-done');
        };

        window.saveAsDefault = function() {
            const settings = getOverridesFromUI();
            settings.maxChapters = parseInt(document.getElementById('maxChapters').value) || 20;
            settings.simRuns = parseInt(document.getElementById('simRuns').value) || 1;
            localStorage.setItem('balanceTunerSettings', JSON.stringify(settings));
            showStatus('Settings saved to browser', 'status-done');
        };

        function loadSavedSettings() {
            const saved = localStorage.getItem('balanceTunerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    applySettings(settings);
                    if (settings.maxChapters) {
                        document.getElementById('maxChapters').value = settings.maxChapters;
                    }
                    if (settings.simRuns) {
                        document.getElementById('simRuns').value = settings.simRuns;
                    }
                } catch (e) {
                    console.warn('Failed to load saved settings:', e);
                }
            }
        }

        function applySettings(settings) {
            setSlider('basePowerPerLevel', settings.basePowerPerLevel);
            setSlider('powerGrowthPerLevel', settings.powerGrowthPerLevel);
            setSlider('powerVariance', settings.powerVariance);
            setSlider('minLevelOffset', settings.minLevelOffset);
            setSlider('maxRarityLevelOffset', settings.maxRarityLevelOffset);
            if (settings.guaranteedUpgradeEveryN !== undefined) {
                setSlider('guaranteedUpgradeEveryN', settings.guaranteedUpgradeEveryN);
            }
            if (settings.guaranteedUpgradeIncreaseEveryNStages !== undefined) {
                setSlider('guaranteedUpgradeIncreaseEveryNStages', settings.guaranteedUpgradeIncreaseEveryNStages);
            }
            if (settings.guaranteedRarityEnabled !== undefined) {
                document.getElementById('guaranteedRarityEnabled').checked = settings.guaranteedRarityEnabled;
                document.getElementById('guaranteedRarityEnabled-val').textContent = settings.guaranteedRarityEnabled ? 'ON' : 'OFF';
            }
            if (settings.guaranteedRarityIntervalMultiplier !== undefined) {
                setSlider('guaranteedRarityIntervalMultiplier', settings.guaranteedRarityIntervalMultiplier);
            }
            if (settings.guaranteedRarityLevelOffset !== undefined) {
                setSlider('guaranteedRarityLevelOffset', settings.guaranteedRarityLevelOffset);
            }
            setSlider('bossPowerMultiplier', settings.bossPowerMultiplier);
            if (settings.minProbForGradualGrowth !== undefined) {
                setSlider('minProbForGradualGrowth', settings.minProbForGradualGrowth);
            }
            if (settings.stepsToTarget !== undefined) {
                setSlider('stepsToTarget', settings.stepsToTarget);
            }
            if (settings.baseDropsForMultiplier !== undefined) {
                setSlider('baseDropsForMultiplier', settings.baseDropsForMultiplier);
            }
            if (settings.dropsPerChapter !== undefined) {
                setSlider('dropsPerChapter', settings.dropsPerChapter);
            }

            if (settings.rarityMultipliers) {
                document.getElementById('rarity-common').value = settings.rarityMultipliers.common;
                document.getElementById('rarity-good').value = settings.rarityMultipliers.good;
                document.getElementById('rarity-rare').value = settings.rarityMultipliers.rare;
                document.getElementById('rarity-epic').value = settings.rarityMultipliers.epic;
                document.getElementById('rarity-mythic').value = settings.rarityMultipliers.mythic;
                document.getElementById('rarity-legendary').value = settings.rarityMultipliers.legendary;
                document.getElementById('rarity-immortal').value = settings.rarityMultipliers.immortal;
            }
        }

        function showStatus(message, className) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = className;
            setTimeout(() => {
                if (statusEl.textContent === message) {
                    statusEl.textContent = '';
                    statusEl.className = '';
                }
            }, 2000);
        }

        window.showTab = function(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(`${tab}-content`).classList.add('active');
        };

        function getOverridesFromUI() {
            return {
                basePowerPerLevel: parseFloat(document.getElementById('basePowerPerLevel').value),
                powerGrowthPerLevel: parseFloat(document.getElementById('powerGrowthPerLevel').value),
                powerVariance: parseFloat(document.getElementById('powerVariance').value),
                minLevelOffset: parseInt(document.getElementById('minLevelOffset').value),
                maxRarityLevelOffset: parseInt(document.getElementById('maxRarityLevelOffset').value),
                guaranteedUpgradeEveryN: parseInt(document.getElementById('guaranteedUpgradeEveryN').value),
                guaranteedUpgradeIncreaseEveryNStages: parseInt(document.getElementById('guaranteedUpgradeIncreaseEveryNStages').value),
                guaranteedRarityEnabled: document.getElementById('guaranteedRarityEnabled').checked,
                guaranteedRarityIntervalMultiplier: parseFloat(document.getElementById('guaranteedRarityIntervalMultiplier').value),
                guaranteedRarityLevelOffset: parseInt(document.getElementById('guaranteedRarityLevelOffset').value),
                bossPowerMultiplier: parseFloat(document.getElementById('bossPowerMultiplier').value),
                minProbForGradualGrowth: parseFloat(document.getElementById('minProbForGradualGrowth').value),
                stepsToTarget: parseInt(document.getElementById('stepsToTarget').value),
                baseDropsForMultiplier: parseInt(document.getElementById('baseDropsForMultiplier').value),
                dropsPerChapter: parseFloat(document.getElementById('dropsPerChapter').value),
                rarityMultipliers: {
                    common: parseFloat(document.getElementById('rarity-common').value),
                    good: parseFloat(document.getElementById('rarity-good').value),
                    rare: parseFloat(document.getElementById('rarity-rare').value),
                    epic: parseFloat(document.getElementById('rarity-epic').value),
                    mythic: parseFloat(document.getElementById('rarity-mythic').value),
                    legendary: parseFloat(document.getElementById('rarity-legendary').value),
                    immortal: parseFloat(document.getElementById('rarity-immortal').value)
                }
            };
        }

        function setSlider(id, value) {
            const el = document.getElementById(id);
            el.value = value;
            el.dispatchEvent(new Event('input'));
        }

        function renderResults(summary, numRuns = 1) {
            document.getElementById('results').classList.add('visible');

            // Summary grid
            const avgLabel = numRuns > 1 ? ' (avg)' : '';
            let summaryHtml = `
                <div class="summary-item">
                    <div class="summary-value">${summary.totalChapters}</div>
                    <div class="summary-label">Chapters</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalLoots}</div>
                    <div class="summary-label">Total Loots${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalBattles}</div>
                    <div class="summary-label">Battles${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.totalDefeats}</div>
                    <div class="summary-label">Defeats${avgLabel}</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.finalHeroLevel}</div>
                    <div class="summary-label">Final Hero Lvl</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value">${summary.finalLampLevel}</div>
                    <div class="summary-label">Final Lamp Lvl</div>
                </div>
            `;

            // Добавляем статистику дисперсии если есть (только при numRuns > 1)
            if (summary.varianceStats) {
                const vs = summary.varianceStats;
                summaryHtml += `
                <div class="summary-item" style="background: #3a2a4e;">
                    <div class="summary-value">${vs.maxLootsPerStage.avg} ±${vs.maxLootsPerStage.std}</div>
                    <div class="summary-label">Max Loots/Stage (${vs.maxLootsPerStage.min}-${vs.maxLootsPerStage.max})</div>
                </div>
                <div class="summary-item" style="background: #3a2a4e;">
                    <div class="summary-value">${vs.maxLootsPerChapter.avg} ±${vs.maxLootsPerChapter.std}</div>
                    <div class="summary-label">Max Loots/Chapter (${vs.maxLootsPerChapter.min}-${vs.maxLootsPerChapter.max})</div>
                </div>
                `;
            }

            document.getElementById('summary-grid').innerHTML = summaryHtml;

            // Tables
            renderChaptersTable(summary.chapters);
            renderStagesTable(summary.stages);

            // Charts
            renderLootsChart(summary.stages);
            renderLootsChapterChart(summary.chapters, summary.stages);
            renderLampMultChart(summary.chapters, summary.stages);
            renderRarityChart(summary.chapters);
            renderEquippedChart(summary.chapters);
            renderExpectedRarityChart(summary.stages);
            renderItemLevelChart(summary.chapters);
            renderUnfairChart(summary.chapters);
            renderPowerChart(summary.chapters);
        }

        function renderChaptersTable(chapters) {
            let html = `<table>
                <tr>
                    <th>Ch</th><th>Loots</th><th>Battles</th><th>Defeats</th>
                    <th>Unfair</th><th>Lamp</th><th>HeroLvl</th><th>Power</th><th>Enemy</th>
                </tr>`;

            for (const c of chapters) {
                html += `<tr>
                    <td>${c.chapter}</td>
                    <td>${c.loots}</td>
                    <td>${c.battles}</td>
                    <td>${c.defeats}</td>
                    <td>${c.unfairDefeats}</td>
                    <td>${c.lampLevel}</td>
                    <td>${c.heroLevel}</td>
                    <td>${c.heroPower}</td>
                    <td>${c.maxEnemyPower}</td>
                </tr>`;
            }

            html += '</table>';
            document.getElementById('chapters-table').innerHTML = html;
        }

        function renderStagesTable(stages) {
            let html = `<table>
                <tr>
                    <th>Ch.St</th><th>Loots</th><th>Defeats</th>
                    <th>HLvl</th><th>Power</th><th>Enemy</th><th>Lamp</th>
                </tr>`;

            for (const s of stages) {
                html += `<tr>
                    <td>${s.chapter}.${s.stage}</td>
                    <td>${s.loots}</td>
                    <td>${s.defeats}</td>
                    <td>${s.heroLevel}</td>
                    <td>${s.heroPower}</td>
                    <td>${s.enemyPower}</td>
                    <td>${s.lampLevel}</td>
                </tr>`;
            }

            html += '</table>';
            document.getElementById('stages-table').innerHTML = html;
        }

        function renderPowerChart(chapters) {
            const canvas = document.getElementById('power-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 40, right: 80, bottom: 60, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const heroPowers = chapters.map(c => c.heroPower);
            const enemyPowers = chapters.map(c => c.maxEnemyPower);
            const maxPower = Math.max(...heroPowers, ...enemyPowers);
            const minPower = Math.min(...heroPowers.filter(p => p > 0), ...enemyPowers.filter(p => p > 0));

            const logMin = Math.log10(Math.max(1, minPower));
            const logMax = Math.log10(maxPower);

            const xScale = (i) => padding.left + (i / Math.max(1, chapters.length - 1)) * width;
            const yScale = (v) => {
                const logV = Math.log10(Math.max(1, v));
                return padding.top + height - ((logV - logMin) / (logMax - logMin)) * height;
            };

            // Save data for tooltip
            chartData.power = { chapters, padding, width, height, xScale };

            // Vertical grid (chapter lines)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + height);
                ctx.stroke();
            }

            // Horizontal grid (power levels)
            for (let p = Math.ceil(logMin); p <= Math.floor(logMax); p++) {
                const y = yScale(Math.pow(10, p));
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();

                ctx.fillStyle = '#888';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'right';
                ctx.fillText(Math.pow(10, p).toLocaleString(), padding.left - 10, y + 4);
            }

            // Hero power line
            ctx.strokeStyle = '#6bff6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(heroPowers[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Hero power points
            ctx.fillStyle = '#6bff6b';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(heroPowers[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Enemy power line
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(enemyPowers[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Enemy power points
            ctx.fillStyle = '#ff6b6b';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                const y = yScale(enemyPowers[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Chapter labels on X axis
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScale(i);
                // Show every Nth label to avoid overlap
                if (chapters.length <= 20 || i % Math.ceil(chapters.length / 20) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // X axis label
            ctx.fillText('Chapter', padding.left + width / 2, canvas.height - 10);

            // Legend
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#6bff6b';
            ctx.fillRect(padding.left + 10, padding.top + 10, 12, 12);
            ctx.fillText('Hero Power', padding.left + 30, padding.top + 20);

            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(padding.left + 10, padding.top + 30, 12, 12);
            ctx.fillText('Enemy Power (Boss)', padding.left + 30, padding.top + 40);
        }

        function renderLootsChart(stages) {
            const canvas = document.getElementById('loots-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const minBarWidth = 2;  // Минимальная ширина бара
            const minCanvasWidth = 1100;

            // Динамическая ширина canvas
            const neededWidth = padding.left + padding.right + stages.length * minBarWidth;
            canvas.width = Math.max(minCanvasWidth, neededWidth);

            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const loots = stages.map(s => s.loots);
            const everyNValues = stages.map(s => s.guaranteedEveryN || 0);
            const rarityIntervalValues = stages.map(s => s.rarityInterval || 0);
            const totalDropsValues = stages.map(s => s.totalDrops || 0);
            const maxLoots = Math.max(...loots, 1);
            const maxEveryN = Math.max(...everyNValues, ...rarityIntervalValues, ...totalDropsValues, 10);

            const barWidth = width / stages.length;

            // Save data for tooltip
            chartData.loots = { stages, padding, width, height, barWidth, maxLoots, maxEveryN };

            // Draw loots bars
            for (let i = 0; i < stages.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = loots[i] > 0 ? '#6bff6b' : '#333';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Draw EveryN line (on right Y axis scale)
            const yScaleEveryN = (v) => padding.top + height - (v / maxEveryN) * height;
            const xScale = (i) => padding.left + i * barWidth + barWidth / 2;

            // Fill area under EveryN line
            ctx.beginPath();
            ctx.moveTo(xScale(0), padding.top + height);
            for (let i = 0; i < stages.length; i++) {
                ctx.lineTo(xScale(i), yScaleEveryN(everyNValues[i]));
            }
            ctx.lineTo(xScale(stages.length - 1), padding.top + height);
            ctx.closePath();
            ctx.fillStyle = '#ffd70022';
            ctx.fill();

            // EveryN line (Guaranteed Upgrade)
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScale(i);
                const y = yScaleEveryN(everyNValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // RarityInterval line (Guaranteed Rarity interval) - cyan/teal color
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScale(i);
                const y = yScaleEveryN(rarityIntervalValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // TotalDrops line (expected drops for calculation) - purple color
            ctx.strokeStyle = '#a855f7';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScale(i);
                const y = yScaleEveryN(totalDropsValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Left Y label (Loots)
            ctx.fillStyle = '#6bff6b';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Right Y label (EveryN)
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'left';
            ctx.fillText(maxEveryN.toString(), padding.left + width + 10, padding.top + 4);
            ctx.fillText('0', padding.left + width + 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.fillStyle = '#6bff6b';
            ctx.fillRect(padding.left + width - 380, padding.top - 20, 12, 12);
            ctx.fillText('Loots', padding.left + width - 365, padding.top - 10);

            ctx.fillStyle = '#ffd700';
            ctx.fillRect(padding.left + width - 310, padding.top - 20, 12, 12);
            ctx.fillText('EveryN', padding.left + width - 295, padding.top - 10);

            ctx.fillStyle = '#22d3ee';
            ctx.fillRect(padding.left + width - 230, padding.top - 20, 12, 12);
            ctx.fillText('RarityInt', padding.left + width - 215, padding.top - 10);

            ctx.fillStyle = '#a855f7';
            ctx.fillRect(padding.left + width - 140, padding.top - 20, 12, 12);
            ctx.fillText('TotalDrops', padding.left + width - 125, padding.top - 10);
        }

        function renderLootsChapterChart(chapters, stages) {
            const canvas = document.getElementById('loots-chapter-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const loots = chapters.map(c => c.loots);
            const maxLoots = Math.max(...loots, 1);

            const barWidth = width / chapters.length;

            // Получаем гарантированную редкость для каждой главы (из последней стадии главы)
            const chapterRarities = chapters.map(ch => {
                // Ищем последнюю стадию этой главы (stage 10)
                const lastStage = stages.find(s => s.chapter === ch.chapter && s.stage === 10);
                return lastStage?.guaranteedRarity || 'common';
            });

            // Save data for tooltip
            chartData.lootsChapter = { chapters, padding, width, height, barWidth, maxLoots, chapterRarities };

            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = '#6bff6b';
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
            }

            // Draw Guaranteed Rarity bar at bottom
            const rarityHeight = 10;
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const rarity = chapterRarities[i];
                ctx.fillStyle = RARITY_COLORS[rarity] || '#9ca3af';
                ctx.fillRect(x + 2, padding.top + height + 2, barWidth - 4, rarityHeight);
            }

            // X labels (chapter numbers)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y label
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Legend for rarity
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#888';
            ctx.fillText('Rarity ▼', padding.left + width - 60, padding.top - 10);
        }

        function renderLampMultChart(chapters, stages) {
            const canvas = document.getElementById('lamp-mult-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0 || stages.length === 0) return;

            // Lamp level data (by chapter)
            const lampLevels = chapters.map(c => c.lampLevel);
            const maxLamp = Math.max(...lampLevels, 31);

            // Multiplier data (by stage)
            const targetValues = stages.map(s => s.rarityMultiplier || 1);
            const currentValues = stages.map(s => s.currentRarityMultiplier || s.rarityMultiplier || 1);
            const maxMult = Math.max(...targetValues, ...currentValues, 2);

            // Scales
            const xScaleChapter = (i) => padding.left + (i / Math.max(1, chapters.length - 1)) * width;
            const xScaleStage = (i) => padding.left + (i / Math.max(1, stages.length - 1)) * width;
            const yScaleLamp = (v) => padding.top + height - (v / maxLamp) * height;
            const yScaleMult = (v) => padding.top + height - ((v - 1) / (maxMult - 1)) * height;

            // Save data for tooltip
            chartData.lampMult = { chapters, stages, padding, width, height, maxLamp, maxMult };

            // Grid (based on lamp levels)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let lvl = 0; lvl <= maxLamp; lvl += 5) {
                const y = yScaleLamp(lvl);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();
            }

            // === Multiplier lines (by stage) ===
            // Target line (dashed gray)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScaleStage(i);
                const y = yScaleMult(targetValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Current multiplier line (cyan)
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < stages.length; i++) {
                const x = xScaleStage(i);
                const y = yScaleMult(currentValues[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // === Lamp level line (by chapter) ===
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                const y = yScaleLamp(lampLevels[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Lamp level points
            ctx.fillStyle = '#ffd700';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                const y = yScaleLamp(lampLevels[i]);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // X labels (chapters)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = xScaleChapter(i);
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Left Y axis labels (Lamp Level)
            ctx.textAlign = 'right';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(maxLamp.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Right Y axis labels (Multiplier)
            ctx.textAlign = 'left';
            ctx.fillStyle = '#22d3ee';
            ctx.fillText('×' + maxMult.toFixed(1), padding.left + width + 10, padding.top + 4);
            ctx.fillText('×1.0', padding.left + width + 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendX = padding.left + 10;
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(legendX, padding.top + 5, 12, 3);
            ctx.fillText('Lamp Lvl', legendX + 16, padding.top + 10);
            ctx.fillStyle = '#22d3ee';
            ctx.fillRect(legendX + 80, padding.top + 5, 12, 3);
            ctx.fillText('Mult', legendX + 96, padding.top + 10);
            ctx.fillStyle = '#666';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(legendX + 130, padding.top + 7);
            ctx.lineTo(legendX + 142, padding.top + 7);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillText('Target', legendX + 146, padding.top + 10);
        }

        function renderRarityChart(chapters) {
            const canvas = document.getElementById('rarity-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            // Calculate max total for scaling
            let maxTotal = 0;
            for (const ch of chapters) {
                let total = 0;
                for (const rarity of RARITY_ORDER) {
                    total += ch.lootsByRarity?.[rarity] || 0;
                }
                if (total > maxTotal) maxTotal = total;
            }
            if (maxTotal === 0) maxTotal = 1;

            const barWidth = width / chapters.length;

            // Save data for tooltip
            chartData.rarity = { chapters, padding, width, height, barWidth, maxTotal };

            // Draw stacked bars
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                let yOffset = 0;

                for (const rarity of RARITY_ORDER) {
                    const count = chapters[i].lootsByRarity?.[rarity] || 0;
                    const barHeight = (count / maxTotal) * height;

                    ctx.fillStyle = RARITY_COLORS[rarity];
                    ctx.fillRect(x + 1, padding.top + height - yOffset - barHeight, barWidth - 2, barHeight);

                    yOffset += barHeight;
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels
            ctx.textAlign = 'right';
            ctx.fillText(maxTotal.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendY = padding.top;
            for (const rarity of [...RARITY_ORDER].reverse()) {
                ctx.fillStyle = RARITY_COLORS[rarity];
                ctx.fillRect(padding.left + width + 10, legendY, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(rarity, padding.left + width + 28, legendY + 10);
                legendY += 18;
            }
        }

        function renderEquippedChart(chapters) {
            const canvas = document.getElementById('equipped-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const barWidth = width / chapters.length;

            // Save data for tooltip
            chartData.equipped = { chapters, padding, width, height, barWidth };

            // Draw 100% stacked bars (normalized to total equipped slots)
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const equipped = chapters[i].equippedByRarity || {};

                // Calculate total equipped slots
                let totalSlots = 0;
                for (const rarity of RARITY_ORDER) {
                    totalSlots += equipped[rarity] || 0;
                }
                if (totalSlots === 0) totalSlots = 1;

                let yOffset = 0;
                for (const rarity of RARITY_ORDER) {
                    const count = equipped[rarity] || 0;
                    const barHeight = (count / totalSlots) * height;

                    ctx.fillStyle = RARITY_COLORS[rarity];
                    ctx.fillRect(x + 1, padding.top + height - yOffset - barHeight, barWidth - 2, barHeight);

                    yOffset += barHeight;
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels (percentage)
            ctx.textAlign = 'right';
            ctx.fillText('100%', padding.left - 10, padding.top + 4);
            ctx.fillText('0%', padding.left - 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendY = padding.top;
            for (const rarity of [...RARITY_ORDER].reverse()) {
                ctx.fillStyle = RARITY_COLORS[rarity];
                ctx.fillRect(padding.left + width + 10, legendY, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(rarity, padding.left + width + 28, legendY + 10);
                legendY += 18;
            }
        }

        // Expected Rarity per Chapter (based on Coupon Collector formula)
        // Shows theoretical slot distribution based on lamp weights and totalDrops
        function renderExpectedRarityChart(stages) {
            const canvas = document.getElementById('expected-rarity-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (stages.length === 0) return;

            // Group stages by chapter (take last stage of each chapter for display)
            const chapterStages = [];
            let currentChapter = 0;
            for (const stage of stages) {
                if (stage.chapter !== currentChapter) {
                    currentChapter = stage.chapter;
                }
                // Always update to get the last stage of each chapter
                if (stage.stage === 10 || stages.indexOf(stage) === stages.length - 1) {
                    chapterStages.push(stage);
                }
            }

            const barWidth = width / chapterStages.length;

            // Save data for tooltip
            chartData.expectedRarity = { stages: chapterStages, padding, width, height, barWidth };

            // Calculate expected rarity distribution for each chapter
            // Using the same formula as calculateSlotBasedRarityMultiplier
            const overrides = getOverridesFromUI();
            const rarityMultipliers = overrides.rarityMultipliers;
            const baseDrops = overrides.baseDropsForMultiplier;
            const dropsPerChapter = overrides.dropsPerChapter;

            // Get lamp weights from lamp-levels.json (imported via the tester)
            // We'll compute expected distribution based on stage data

            for (let i = 0; i < chapterStages.length; i++) {
                const stage = chapterStages[i];
                const x = padding.left + i * barWidth;

                // Get slot count and totalDrops from stage
                const totalSlots = stage.slots || 6;
                const totalDrops = stage.totalDrops || (baseDrops + (stage.chapter - 1) * dropsPerChapter);
                const lampLevel = stage.lampLevel;

                // Calculate expected distribution
                const expected = calculateExpectedDistribution(lampLevel, totalSlots, totalDrops, rarityMultipliers);

                // Draw 100% stacked bar
                let yOffset = 0;
                for (const rarity of RARITY_ORDER) {
                    const slotCount = expected[rarity] || 0;
                    const barHeight = (slotCount / totalSlots) * height;

                    if (barHeight > 0) {
                        ctx.fillStyle = RARITY_COLORS[rarity];
                        ctx.fillRect(x + 1, padding.top + height - yOffset - barHeight, barWidth - 2, barHeight);
                        yOffset += barHeight;
                    }
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapterStages.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapterStages.length <= 30 || i % Math.ceil(chapterStages.length / 30) === 0) {
                    ctx.fillText(chapterStages[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels (percentage)
            ctx.textAlign = 'right';
            ctx.fillText('100%', padding.left - 10, padding.top + 4);
            ctx.fillText('0%', padding.left - 10, padding.top + height + 4);

            // Legend
            ctx.font = '11px Courier New';
            ctx.textAlign = 'left';
            let legendY = padding.top;
            for (const rarity of [...RARITY_ORDER].reverse()) {
                ctx.fillStyle = RARITY_COLORS[rarity];
                ctx.fillRect(padding.left + width + 10, legendY, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(rarity, padding.left + width + 28, legendY + 10);
                legendY += 18;
            }
        }

        // Calculate expected slot distribution using Coupon Collector formula
        // Mirrors the logic in calculateSlotBasedRarityMultiplier
        function calculateExpectedDistribution(lampLevel, totalSlots, totalDrops, rarityMultipliers) {
            // Lamp weights by level (hardcoded key levels, interpolated)
            const lampWeights = getLampWeightsForLevel(lampLevel);

            const result = {};
            for (const rarity of RARITY_ORDER) {
                result[rarity] = 0;
            }

            // Calculate total weight
            let totalWeight = 0;
            for (const weight of Object.values(lampWeights)) {
                if (weight > 0) totalWeight += weight;
            }
            if (totalWeight === 0) {
                result['common'] = totalSlots;
                return result;
            }

            // Build valid rarities with prob and mult, sorted by mult descending
            const validRarities = [];
            for (const [rarity, weight] of Object.entries(lampWeights)) {
                if (weight <= 0) continue;
                const prob = weight / totalWeight;
                const mult = rarityMultipliers[rarity] || 1.0;
                validRarities.push({ rarity, prob, mult });
            }
            validRarities.sort((a, b) => b.mult - a.mult);

            // Calculate slot filling
            let remainingSlots = totalSlots;

            for (const { rarity, prob } of validRarities) {
                if (remainingSlots < 1) break;

                const drops = totalDrops * prob;
                const expectedFilled = remainingSlots * (1 - Math.pow((remainingSlots - 1) / remainingSlots, drops));

                // Skip if expectedFilled < 1
                if (expectedFilled < 1) continue;

                const filledSlots = Math.min(expectedFilled, remainingSlots);
                result[rarity] = filledSlots;
                remainingSlots -= filledSlots;
            }

            // Remaining slots go to common
            if (remainingSlots > 0) {
                result['common'] = (result['common'] || 0) + remainingSlots;
            }

            return result;
        }

        // Get lamp weights for a given level (simplified lookup)
        function getLampWeightsForLevel(level) {
            // Hardcoded from lamp-levels.json
            const lampLevels = [
                { level: 1, weights: { common: 100 } },
                { level: 2, weights: { common: 99, good: 1 } },
                { level: 7, weights: { common: 90, good: 10 } },
                { level: 8, weights: { common: 80, good: 20, rare: 0.01 } },
                { level: 15, weights: { common: 18, good: 81, rare: 1 } },
                { level: 20, weights: { common: 8, good: 82, rare: 10 } },
                { level: 21, weights: { good: 80, rare: 20, epic: 0.01 } },
                { level: 28, weights: { good: 18, rare: 81, epic: 1 } },
                { level: 33, weights: { good: 8, rare: 82, epic: 10 } }
            ];

            // Find closest level
            let closest = lampLevels[0];
            for (const l of lampLevels) {
                if (l.level <= level) closest = l;
            }
            return closest.weights;
        }

        // Render Item Level chart: Expected vs Actual per chapter
        function renderItemLevelChart(chapters) {
            const canvas = document.getElementById('item-level-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 120, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            // Expected item level = heroLevel (which equals chapter number at end of chapter)
            // Actual item level = avgItemLevel from chapter data
            const maxLevel = Math.max(...chapters.map(c => Math.max(c.heroLevel, c.avgItemLevel || 0))) * 1.1;
            const xScale = width / (chapters.length - 1 || 1);

            // Save data for tooltip
            chartData.itemLevel = { chapters, padding, width, height, xScale, maxLevel };

            // Y-axis scale
            const yScale = height / maxLevel;

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();
            }

            // Draw Expected line (heroLevel = chapter)
            ctx.strokeStyle = '#4ade80';  // green
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * xScale;
                const y = padding.top + height - chapters[i].heroLevel * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw Actual line (avgItemLevel)
            ctx.strokeStyle = '#f97316';  // orange
            ctx.lineWidth = 2;
            ctx.beginPath();
            let hasActual = false;
            for (let i = 0; i < chapters.length; i++) {
                const avgLevel = chapters[i].avgItemLevel || 0;
                if (avgLevel > 0) {
                    const x = padding.left + i * xScale;
                    const y = padding.top + height - avgLevel * yScale;
                    if (!hasActual) {
                        ctx.moveTo(x, y);
                        hasActual = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            if (hasActual) ctx.stroke();

            // X labels (chapter numbers)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * xScale;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = Math.round(maxLevel * (5 - i) / 5);
                const y = padding.top + (height / 5) * i + 4;
                ctx.fillText(val.toString(), padding.left - 10, y);
            }

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText('Item Level', padding.left, padding.top - 10);

            // Legend
            ctx.font = '11px Courier New';
            let legendY = padding.top + 20;

            ctx.fillStyle = '#4ade80';
            ctx.fillRect(padding.left + width + 10, legendY, 20, 3);
            ctx.fillStyle = '#888';
            ctx.fillText('Expected', padding.left + width + 35, legendY + 4);
            legendY += 20;

            ctx.fillStyle = '#f97316';
            ctx.fillRect(padding.left + width + 10, legendY, 20, 3);
            ctx.fillStyle = '#888';
            ctx.fillText('Actual', padding.left + width + 35, legendY + 4);
        }

        // Render Unfair Battles chart: wins/losses by enemy count (1/2/3)
        function renderUnfairChart(chapters) {
            const canvas = document.getElementById('unfair-chart');
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 150, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            // Colors for different enemy counts
            const ENEMY_COLORS = {
                wins: ['#22c55e', '#16a34a', '#15803d'],    // green shades (1, 2, 3 enemies)
                losses: ['#ef4444', '#dc2626', '#b91c1c']   // red shades (1, 2, 3 enemies)
            };

            // Calculate cumulative unfair stats
            const cumulativeStats = chapters.map((ch, idx) => {
                const cumWins = [0, 0, 0];
                const cumLosses = [0, 0, 0];
                const cumTotal = [0, 0, 0];
                for (let i = 0; i <= idx; i++) {
                    const stats = chapters[i].unfairStats;
                    if (stats) {
                        for (let j = 0; j < 3; j++) {
                            cumWins[j] += stats.wins[j] || 0;
                            cumLosses[j] += stats.losses[j] || 0;
                            cumTotal[j] += stats.total[j] || 0;
                        }
                    }
                }
                return { cumWins, cumLosses, cumTotal };
            });

            // Find max percentage for Y scale
            let maxPct = 0;
            for (const stats of cumulativeStats) {
                for (let i = 0; i < 3; i++) {
                    if (stats.cumTotal[i] > 0) {
                        const winPct = (stats.cumWins[i] / stats.cumTotal[i]) * 100;
                        const lossPct = (stats.cumLosses[i] / stats.cumTotal[i]) * 100;
                        maxPct = Math.max(maxPct, winPct, lossPct);
                    }
                }
            }
            maxPct = Math.max(maxPct * 1.1, 5);  // At least 5%

            const xScale = width / (chapters.length - 1 || 1);
            const yScale = height / maxPct;

            // Save data for tooltip
            chartData.unfair = { chapters, cumulativeStats, padding, width, height, xScale, maxPct };

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + width, y);
                ctx.stroke();
            }

            // Draw lines for each enemy count (1, 2, 3) - wins and losses
            for (let enemyIdx = 0; enemyIdx < 3; enemyIdx++) {
                // Draw wins line (green)
                ctx.strokeStyle = ENEMY_COLORS.wins[enemyIdx];
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                let hasWins = false;
                for (let i = 0; i < chapters.length; i++) {
                    const stats = cumulativeStats[i];
                    if (stats.cumTotal[enemyIdx] > 0) {
                        const pct = (stats.cumWins[enemyIdx] / stats.cumTotal[enemyIdx]) * 100;
                        const x = padding.left + i * xScale;
                        const y = padding.top + height - pct * yScale;
                        if (!hasWins) {
                            ctx.moveTo(x, y);
                            hasWins = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
                if (hasWins) ctx.stroke();

                // Draw losses line (red, dashed)
                ctx.strokeStyle = ENEMY_COLORS.losses[enemyIdx];
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                let hasLosses = false;
                for (let i = 0; i < chapters.length; i++) {
                    const stats = cumulativeStats[i];
                    if (stats.cumTotal[enemyIdx] > 0) {
                        const pct = (stats.cumLosses[enemyIdx] / stats.cumTotal[enemyIdx]) * 100;
                        const x = padding.left + i * xScale;
                        const y = padding.top + height - pct * yScale;
                        if (!hasLosses) {
                            ctx.moveTo(x, y);
                            hasLosses = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
                if (hasLosses) ctx.stroke();
            }
            ctx.setLineDash([]);

            // X labels (chapter numbers)
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * xScale;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 20);
                }
            }

            // Y labels (percentage)
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = Math.round(maxPct * (5 - i) / 5);
                const y = padding.top + (height / 5) * i + 4;
                ctx.fillText(val + '%', padding.left - 10, y);
            }

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText('Unfair Battles (cumulative %)', padding.left, padding.top - 10);

            // Legend
            ctx.font = '10px Courier New';
            let legendY = padding.top;

            ctx.fillStyle = '#888';
            ctx.fillText('Wins (solid):', padding.left + width + 10, legendY);
            legendY += 14;
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = ENEMY_COLORS.wins[i];
                ctx.fillRect(padding.left + width + 10, legendY, 15, 3);
                ctx.fillStyle = '#888';
                ctx.fillText(`${i + 1} enemy`, padding.left + width + 30, legendY + 4);
                legendY += 14;
            }

            legendY += 10;
            ctx.fillStyle = '#888';
            ctx.fillText('Losses (dashed):', padding.left + width + 10, legendY);
            legendY += 14;
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = ENEMY_COLORS.losses[i];
                ctx.setLineDash([3, 2]);
                ctx.strokeStyle = ENEMY_COLORS.losses[i];
                ctx.beginPath();
                ctx.moveTo(padding.left + width + 10, legendY);
                ctx.lineTo(padding.left + width + 25, legendY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#888';
                ctx.fillText(`${i + 1} enemy`, padding.left + width + 30, legendY + 4);
                legendY += 14;
            }
        }

        // Initialize sliders with value display
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            const valEl = document.getElementById(slider.id + '-val');
            if (!valEl) return;

            slider.addEventListener('input', () => {
                const v = parseFloat(slider.value);
                if (slider.id === 'powerVariance') {
                    valEl.textContent = Math.round(v * 100) + '%';
                } else if (slider.id === 'minProbForGradualGrowth') {
                    valEl.textContent = (v * 100).toFixed(2) + '%';
                } else if (slider.id === 'guaranteedRarityLevelOffset') {
                    valEl.textContent = v === 0 ? '0 (max)' : v.toString();
                } else if (slider.id === 'powerGrowthPerLevel' || slider.id === 'bossPowerMultiplier') {
                    valEl.textContent = v.toFixed(2);
                } else {
                    valEl.textContent = v;
                }
            });

            // Trigger initial display
            slider.dispatchEvent(new Event('input'));
        });

        // Checkbox handler for guaranteedRarityEnabled
        const guaranteedRarityCheckbox = document.getElementById('guaranteedRarityEnabled');
        guaranteedRarityCheckbox.addEventListener('change', () => {
            document.getElementById('guaranteedRarityEnabled-val').textContent = guaranteedRarityCheckbox.checked ? 'ON' : 'OFF';
        });

        // Load saved settings on page load
        loadSavedSettings();

        // Tooltip handlers for Power chart
        const powerCanvas = document.getElementById('power-chart');
        const powerTooltip = document.getElementById('power-tooltip');

        powerCanvas.addEventListener('mousemove', (e) => {
            const rect = powerCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.power;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, width } = data;

            // Find closest chapter
            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                powerTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (chapters.length - 1));
            if (idx < 0 || idx >= chapters.length) {
                powerTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            powerTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${ch.heroPower.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Enemy Power:</span> <span class="tt-value tt-enemy">${ch.maxEnemyPower.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value">${ch.loots}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${ch.defeats}</span></div>
            `;

            // Position tooltip
            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            powerTooltip.style.left = left + 'px';
            powerTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            powerTooltip.classList.add('visible');
        });

        powerCanvas.addEventListener('mouseleave', () => {
            powerTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Loots chart
        const lootsCanvas = document.getElementById('loots-chart');
        const lootsTooltip = document.getElementById('loots-tooltip');

        lootsCanvas.addEventListener('mousemove', (e) => {
            const rect = lootsCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.loots;

            if (!data.stages || data.stages.length === 0) return;

            const { stages, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * stages.length) {
                lootsTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= stages.length) {
                lootsTooltip.classList.remove('visible');
                return;
            }

            const st = stages[idx];
            const rarityColor = RARITY_COLORS[st.guaranteedRarity] || '#9ca3af';
            lootsTooltip.innerHTML = `
                <div class="tt-title">Stage ${st.chapter}.${st.stage}</div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value tt-loots">${st.loots}</span></div>
                <div class="tt-row"><span class="tt-label">EveryN:</span> <span class="tt-value tt-diff">${st.guaranteedEveryN}</span></div>
                <div class="tt-row"><span class="tt-label">RarityInt:</span> <span class="tt-value" style="color:#22d3ee">${st.rarityInterval || '-'}</span></div>
                <div class="tt-row"><span class="tt-label">TotalDrops:</span> <span class="tt-value" style="color:#a855f7">${st.totalDrops || '-'}</span></div>
                <div class="tt-row"><span class="tt-label">Rarity:</span> <span class="tt-value" style="color:${rarityColor}">${st.guaranteedRarity || 'common'}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${st.defeats}</span></div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${st.heroPower.toLocaleString()}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            lootsTooltip.style.left = left + 'px';
            lootsTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lootsTooltip.classList.add('visible');
        });

        lootsCanvas.addEventListener('mouseleave', () => {
            lootsTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Loots Chapter chart
        const lootsChapterCanvas = document.getElementById('loots-chapter-chart');
        const lootsChapterTooltip = document.getElementById('loots-chapter-tooltip');

        lootsChapterCanvas.addEventListener('mousemove', (e) => {
            const rect = lootsChapterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.lootsChapter;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                lootsChapterTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                lootsChapterTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const rarity = data.chapterRarities?.[idx] || 'common';
            const rarityColor = RARITY_COLORS[rarity] || '#9ca3af';
            lootsChapterTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Loots:</span> <span class="tt-value tt-loots">${ch.loots}</span></div>
                <div class="tt-row"><span class="tt-label">Defeats:</span> <span class="tt-value">${ch.defeats}</span></div>
                <div class="tt-row"><span class="tt-label">Rarity:</span> <span class="tt-value" style="color:${rarityColor}">${rarity}</span></div>
                <div class="tt-row"><span class="tt-label">Hero Power:</span> <span class="tt-value tt-hero">${ch.heroPower.toLocaleString()}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            lootsChapterTooltip.style.left = left + 'px';
            lootsChapterTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lootsChapterTooltip.classList.add('visible');
        });

        lootsChapterCanvas.addEventListener('mouseleave', () => {
            lootsChapterTooltip.classList.remove('visible');
        });

        // Tooltip handlers for combined Lamp & Multiplier chart
        const lampMultCanvas = document.getElementById('lamp-mult-chart');
        const lampMultTooltip = document.getElementById('lamp-mult-tooltip');

        lampMultCanvas.addEventListener('mousemove', (e) => {
            const rect = lampMultCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.lampMult;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, stages, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                lampMultTooltip.classList.remove('visible');
                return;
            }

            // Find chapter by x position
            const chapterIdx = Math.round((relX / width) * (chapters.length - 1));
            if (chapterIdx < 0 || chapterIdx >= chapters.length) {
                lampMultTooltip.classList.remove('visible');
                return;
            }

            // Find corresponding stage for multiplier data
            const stageIdx = Math.round((relX / width) * (stages.length - 1));
            const ch = chapters[chapterIdx];
            const st = stages[Math.min(stageIdx, stages.length - 1)];

            const current = st?.currentRarityMultiplier || st?.rarityMultiplier || 1;
            const target = st?.rarityMultiplier || 1;

            lampMultTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label">Lamp Level:</span> <span class="tt-value" style="color:#ffd700">${ch.lampLevel}</span></div>
                <div class="tt-row"><span class="tt-label">Gold Spent:</span> <span class="tt-value">${ch.goldSpent.toLocaleString()}</span></div>
                <div class="tt-row"><span class="tt-label">Current Mult:</span> <span class="tt-value" style="color:#22d3ee">×${current.toFixed(2)}</span></div>
                <div class="tt-row"><span class="tt-label">Target Mult:</span> <span class="tt-value">×${target.toFixed(2)}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 170 > rect.width) left = e.clientX - rect.left - 170;
            lampMultTooltip.style.left = left + 'px';
            lampMultTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            lampMultTooltip.classList.add('visible');
        });

        lampMultCanvas.addEventListener('mouseleave', () => {
            lampMultTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Rarity chart
        const rarityCanvas = document.getElementById('rarity-chart');
        const rarityTooltip = document.getElementById('rarity-tooltip');

        rarityCanvas.addEventListener('mousemove', (e) => {
            const rect = rarityCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.rarity;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                rarityTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                rarityTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const rarityRows = RARITY_ORDER.map(r => {
                const count = ch.lootsByRarity?.[r] || 0;
                return count > 0 ? `<div class="tt-row"><span class="tt-label" style="color:${RARITY_COLORS[r]}">${r}:</span> <span class="tt-value">${count}</span></div>` : '';
            }).join('');

            rarityTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                ${rarityRows}
                <div class="tt-row"><span class="tt-label">Total:</span> <span class="tt-value tt-loots">${ch.loots}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 160 > rect.width) left = e.clientX - rect.left - 160;
            rarityTooltip.style.left = left + 'px';
            rarityTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            rarityTooltip.classList.add('visible');
        });

        rarityCanvas.addEventListener('mouseleave', () => {
            rarityTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Equipped chart
        const equippedCanvas = document.getElementById('equipped-chart');
        const equippedTooltip = document.getElementById('equipped-tooltip');

        equippedCanvas.addEventListener('mousemove', (e) => {
            const rect = equippedCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.equipped;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * chapters.length) {
                equippedTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= chapters.length) {
                equippedTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const equipped = ch.equippedByRarity || {};

            // Calculate total and percentages
            let totalSlots = 0;
            for (const r of RARITY_ORDER) {
                totalSlots += equipped[r] || 0;
            }

            const equippedRows = RARITY_ORDER.map(r => {
                const count = equipped[r] || 0;
                const pct = totalSlots > 0 ? Math.round(count / totalSlots * 100) : 0;
                return count > 0 ? `<div class="tt-row"><span class="tt-label" style="color:${RARITY_COLORS[r]}">${r}:</span> <span class="tt-value">${count} (${pct}%)</span></div>` : '';
            }).join('');

            equippedTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                ${equippedRows}
                <div class="tt-row"><span class="tt-label">Total slots:</span> <span class="tt-value">${totalSlots}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            equippedTooltip.style.left = left + 'px';
            equippedTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            equippedTooltip.classList.add('visible');
        });

        equippedCanvas.addEventListener('mouseleave', () => {
            equippedTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Expected Rarity chart
        const expectedRarityCanvas = document.getElementById('expected-rarity-chart');
        const expectedRarityTooltip = document.getElementById('expected-rarity-tooltip');

        expectedRarityCanvas.addEventListener('mousemove', (e) => {
            const rect = expectedRarityCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.expectedRarity;

            if (!data.stages || data.stages.length === 0) return;

            const { stages, padding, barWidth } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > barWidth * stages.length) {
                expectedRarityTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.floor(relX / barWidth);
            if (idx < 0 || idx >= stages.length) {
                expectedRarityTooltip.classList.remove('visible');
                return;
            }

            const stage = stages[idx];
            const overrides = getOverridesFromUI();
            const rarityMultipliers = overrides.rarityMultipliers;
            const baseDrops = overrides.baseDropsForMultiplier;
            const dropsPerChapter = overrides.dropsPerChapter;

            const totalSlots = stage.slots || 6;
            const totalDrops = stage.totalDrops || (baseDrops + (stage.chapter - 1) * dropsPerChapter);
            const lampLevel = stage.lampLevel;

            // Calculate expected distribution
            const expected = calculateExpectedDistribution(lampLevel, totalSlots, totalDrops, rarityMultipliers);

            // Calculate total and percentages
            let totalFilled = 0;
            for (const r of RARITY_ORDER) {
                totalFilled += expected[r] || 0;
            }

            const expectedRows = RARITY_ORDER.map(r => {
                const count = expected[r] || 0;
                const pct = totalSlots > 0 ? Math.round(count / totalSlots * 100) : 0;
                return count > 0.01 ? `<div class="tt-row"><span class="tt-label" style="color:${RARITY_COLORS[r]}">${r}:</span> <span class="tt-value">${count.toFixed(1)} (${pct}%)</span></div>` : '';
            }).join('');

            expectedRarityTooltip.innerHTML = `
                <div class="tt-title">Chapter ${stage.chapter}</div>
                <div class="tt-row"><span class="tt-label">Lamp:</span> <span class="tt-value">${lampLevel}</span></div>
                <div class="tt-row"><span class="tt-label">Slots:</span> <span class="tt-value">${totalSlots}</span></div>
                <div class="tt-row"><span class="tt-label">Drops:</span> <span class="tt-value">${totalDrops}</span></div>
                <hr style="border-color:#444; margin:4px 0">
                ${expectedRows}
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 180 > rect.width) left = e.clientX - rect.left - 180;
            expectedRarityTooltip.style.left = left + 'px';
            expectedRarityTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            expectedRarityTooltip.classList.add('visible');
        });

        expectedRarityCanvas.addEventListener('mouseleave', () => {
            expectedRarityTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Item Level chart
        const itemLevelCanvas = document.getElementById('item-level-chart');
        const itemLevelTooltip = document.getElementById('item-level-tooltip');

        itemLevelCanvas.addEventListener('mousemove', (e) => {
            const rect = itemLevelCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.itemLevel;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                itemLevelTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (chapters.length - 1));
            if (idx < 0 || idx >= chapters.length) {
                itemLevelTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const expected = ch.heroLevel;
            const actual = ch.avgItemLevel || 0;
            const diff = actual - expected;
            const diffStr = diff >= 0 ? `+${diff.toFixed(1)}` : diff.toFixed(1);

            itemLevelTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter}</div>
                <div class="tt-row"><span class="tt-label" style="color:#4ade80">Expected:</span> <span class="tt-value">${expected}</span></div>
                <div class="tt-row"><span class="tt-label" style="color:#f97316">Actual:</span> <span class="tt-value">${actual.toFixed(1)}</span></div>
                <div class="tt-row"><span class="tt-label">Diff:</span> <span class="tt-value">${diffStr}</span></div>
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 150 > rect.width) left = e.clientX - rect.left - 150;
            itemLevelTooltip.style.left = left + 'px';
            itemLevelTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            itemLevelTooltip.classList.add('visible');
        });

        itemLevelCanvas.addEventListener('mouseleave', () => {
            itemLevelTooltip.classList.remove('visible');
        });

        // Tooltip handlers for Unfair Battles chart
        const unfairCanvas = document.getElementById('unfair-chart');
        const unfairTooltip = document.getElementById('unfair-tooltip');

        unfairCanvas.addEventListener('mousemove', (e) => {
            const rect = unfairCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const data = chartData.unfair;

            if (!data.chapters || data.chapters.length === 0) return;

            const { chapters, cumulativeStats, padding, width } = data;

            const relX = x - padding.left;
            if (relX < 0 || relX > width) {
                unfairTooltip.classList.remove('visible');
                return;
            }

            const idx = Math.round((relX / width) * (chapters.length - 1));
            if (idx < 0 || idx >= chapters.length) {
                unfairTooltip.classList.remove('visible');
                return;
            }

            const ch = chapters[idx];
            const stats = cumulativeStats[idx];

            // Build tooltip rows for each enemy count
            let rows = '';
            for (let i = 0; i < 3; i++) {
                const total = stats.cumTotal[i];
                const wins = stats.cumWins[i];
                const losses = stats.cumLosses[i];
                const winPct = total > 0 ? (wins / total * 100).toFixed(1) : '0.0';
                const lossPct = total > 0 ? (losses / total * 100).toFixed(1) : '0.0';
                rows += `<div class="tt-row"><span class="tt-label">${i + 1} enemy:</span> <span class="tt-value" style="color:#22c55e">W:${wins} (${winPct}%)</span> <span class="tt-value" style="color:#ef4444">L:${losses} (${lossPct}%)</span> / ${total}</div>`;
            }

            unfairTooltip.innerHTML = `
                <div class="tt-title">Chapter ${ch.chapter} (cumulative)</div>
                ${rows}
            `;

            let left = e.clientX - rect.left + 15;
            if (left + 220 > rect.width) left = e.clientX - rect.left - 220;
            unfairTooltip.style.left = left + 'px';
            unfairTooltip.style.top = (e.clientY - rect.top - 50) + 'px';
            unfairTooltip.classList.add('visible');
        });

        unfairCanvas.addEventListener('mouseleave', () => {
            unfairTooltip.classList.remove('visible');
        });
    </script>
</body>
</html>
