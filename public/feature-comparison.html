<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature Comparison</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            margin: 0;
        }
        h1, h2, h3, h4 { color: #ffd700; margin-bottom: 10px; }
        .container { max-width: 1400px; margin: 0 auto; }

        /* Controls Panel */
        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            background: #2a2a4e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-group {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
        }
        .control-group h3 {
            margin-top: 0;
            font-size: 14px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }
        .control-row label {
            flex: 1;
            font-size: 12px;
            color: #aaa;
        }
        .control-row input[type="range"] {
            width: 100px;
        }
        .control-row input[type="number"] {
            width: 70px;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 4px;
            border-radius: 4px;
            text-align: right;
        }
        .control-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .value-display {
            width: 60px;
            text-align: right;
            font-size: 12px;
            color: #ffd700;
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }
        .btn-primary {
            background: #ffd700;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover { background: #ffed4a; }
        .btn-primary:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #444;
            color: #eee;
        }
        .btn-secondary:hover { background: #555; }

        /* Status */
        #status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        .status-running { background: #444422; color: #ffd700; }
        .status-done { background: #224422; color: #6bff6b; }
        .status-error { background: #442222; color: #ff6b6b; }

        /* Layers Container */
        #layers-container {
            margin-top: 20px;
        }

        /* Layer */
        .layer {
            background: #2a2a4e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .layer h3 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        /* Charts Row */
        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 1200px) {
            .charts-row {
                grid-template-columns: 1fr;
            }
        }

        /* Chart Container */
        .chart-container {
            position: relative;
        }
        .chart-container h4 {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
        }
        .chart-scroll {
            overflow-x: auto;
            max-width: 100%;
        }

        /* Canvas */
        canvas {
            background: #1a1a2e;
            border-radius: 8px;
        }

        /* Summary in layer */
        .layer-summary {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .summary-item {
            background: #1a1a2e;
            padding: 8px 12px;
            border-radius: 4px;
            text-align: center;
        }
        .summary-value {
            font-size: 18px;
            color: #ffd700;
            font-weight: bold;
        }
        .summary-label {
            font-size: 10px;
            color: #888;
        }
        .summary-diff {
            font-size: 10px;
            margin-left: 4px;
        }
        .diff-positive { color: #ff6b6b; }
        .diff-negative { color: #6bff6b; }
        .diff-neutral { color: #888; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Feature Comparison</h1>
        <p style="color: #888; margin-bottom: 20px;">Послойная визуализация влияния фич на экономику</p>

        <!-- Controls -->
        <div class="controls-panel">
            <!-- Common Settings -->
            <div class="control-group">
                <h3>Simulation</h3>
                <div class="control-row">
                    <label>Max Chapters</label>
                    <input type="number" id="maxChapters" value="30" min="1" max="100">
                </div>
                <div class="control-row">
                    <label>Runs (avg)</label>
                    <input type="number" id="simRuns" value="1" min="1" max="100">
                </div>
            </div>

            <!-- Feature 1: Item Level -->
            <div class="control-group">
                <h3>Feature 1: Item Level (Guaranteed Rarity)</h3>
                <div class="control-row">
                    <label>Enabled</label>
                    <input type="checkbox" id="itemLevel-enabled" checked>
                </div>
                <div class="control-row">
                    <label>Interval Multiplier</label>
                    <input type="range" id="itemLevel-multiplier" min="0" max="5" step="0.1" value="1">
                    <span class="value-display" id="itemLevel-multiplier-display">1.0</span>
                </div>
                <div class="control-row">
                    <label>Level Offset</label>
                    <input type="range" id="itemLevel-offset" min="-5" max="0" step="1" value="0">
                    <span class="value-display" id="itemLevel-offset-display">0</span>
                </div>
            </div>

            <!-- Feature 2: Power Variance -->
            <div class="control-group">
                <h3>Feature 2: Power Variance</h3>
                <div class="control-row">
                    <label>Enabled</label>
                    <input type="checkbox" id="powerVariance-enabled" checked>
                </div>
                <div class="control-row">
                    <label>Variance</label>
                    <input type="range" id="powerVariance-value" min="0" max="0.5" step="0.05" value="0.15">
                    <span class="value-display" id="powerVariance-value-display">0.15</span>
                </div>
            </div>

            <!-- Feature 3: Guaranteed Upgrade -->
            <div class="control-group">
                <h3>Feature 3: Guaranteed Upgrade</h3>
                <div class="control-row">
                    <label>Enabled</label>
                    <input type="checkbox" id="guaranteedUpgrade-enabled" checked>
                </div>
                <div class="control-row">
                    <label>Every N Loots</label>
                    <input type="range" id="guaranteedUpgrade-everyN" min="0" max="20" step="1" value="4">
                    <span class="value-display" id="guaranteedUpgrade-everyN-display">4</span>
                </div>
                <div class="control-row">
                    <label>Increase Every N Stages</label>
                    <input type="range" id="guaranteedUpgrade-increase" min="0" max="50" step="5" value="10">
                    <span class="value-display" id="guaranteedUpgrade-increase-display">10</span>
                </div>
            </div>

            <!-- Feature 4: Rarity Display -->
            <div class="control-group">
                <h3>Feature 4: Rarity Display</h3>
                <div class="control-row">
                    <label>Enabled</label>
                    <input type="checkbox" id="rarity-enabled" checked>
                </div>
                <p style="font-size: 10px; color: #666; margin: 5px 0 0 0;">Показывает полоску редкости на графике Loots per Chapter</p>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" onclick="runComparison()">Run Comparison</button>
        </div>

        <div id="status"></div>

        <!-- Layers will be generated dynamically -->
        <div id="layers-container"></div>
    </div>

    <script type="module">
        import { runSimulation as runSim, getDefaults } from '/src/testing/BrowserEconomyTester.ts';

        const RARITY_COLORS = {
            common: '#9ca3af',
            good: '#22c55e',
            rare: '#3b82f6',
            epic: '#a855f7',
            mythic: '#f43f5e',
            legendary: '#f59e0b',
            immortal: '#fbbf24'
        };

        // Feature definitions
        const FEATURES = [
            {
                id: 'itemLevel',
                name: 'Item Level',
                getOverrides: () => ({
                    guaranteedRarityEnabled: true,
                    guaranteedRarityIntervalMultiplier: parseFloat(document.getElementById('itemLevel-multiplier').value),
                    guaranteedRarityLevelOffset: parseInt(document.getElementById('itemLevel-offset').value)
                }),
                getDisabled: () => ({
                    guaranteedRarityEnabled: false
                }),
                isEnabled: () => document.getElementById('itemLevel-enabled').checked
            },
            {
                id: 'powerVariance',
                name: 'Power Variance',
                getOverrides: () => ({
                    powerVariance: parseFloat(document.getElementById('powerVariance-value').value)
                }),
                getDisabled: () => ({
                    powerVariance: 0
                }),
                isEnabled: () => document.getElementById('powerVariance-enabled').checked
            },
            {
                id: 'guaranteedUpgrade',
                name: 'Guaranteed Upgrade',
                getOverrides: () => ({
                    guaranteedUpgradeEveryN: parseInt(document.getElementById('guaranteedUpgrade-everyN').value),
                    guaranteedUpgradeIncreaseEveryNStages: parseInt(document.getElementById('guaranteedUpgrade-increase').value)
                }),
                getDisabled: () => ({
                    guaranteedUpgradeEveryN: 0
                }),
                isEnabled: () => document.getElementById('guaranteedUpgrade-enabled').checked
            },
            {
                id: 'rarity',
                name: 'Rarity Display',
                getOverrides: () => ({}),  // Не меняет симуляцию
                getDisabled: () => ({}),   // Не меняет симуляцию
                isEnabled: () => document.getElementById('rarity-enabled').checked,
                isVisualOnly: true  // Флаг что это только визуальная фича
            }
        ];

        // Run comparison
        window.runComparison = async function() {
            const status = document.getElementById('status');
            status.textContent = 'Running simulations...';
            status.className = 'status-running';

            const maxChapters = parseInt(document.getElementById('maxChapters').value);
            const numRuns = parseInt(document.getElementById('simRuns').value);

            try {
                const results = [];
                const enabledFeatures = new Set();  // Track which features are enabled for each layer

                // Layer 0: Baseline (all features disabled)
                let overrides = {};
                FEATURES.forEach(f => {
                    Object.assign(overrides, f.getDisabled());
                });

                const baselineSummary = runMultipleSimulations(overrides, maxChapters, numRuns);
                results.push({
                    name: 'Baseline',
                    summary: baselineSummary,
                    enabledFeatures: new Set()  // No features enabled in baseline
                });

                // Layers 1-N: sequentially enable features
                FEATURES.forEach((feature) => {
                    if (!feature.isEnabled()) return;

                    enabledFeatures.add(feature.id);

                    // Visual-only features don't change simulation
                    if (!feature.isVisualOnly) {
                        Object.assign(overrides, feature.getOverrides());
                    }

                    const summary = feature.isVisualOnly
                        ? results[results.length - 1].summary  // Reuse previous summary
                        : runMultipleSimulations(overrides, maxChapters, numRuns);

                    results.push({
                        name: `+ ${feature.name}`,
                        summary: summary,
                        enabledFeatures: new Set(enabledFeatures)  // Copy current set
                    });
                });

                // Render results
                renderLayers(results);

                status.textContent = `Done! ${results.length} layers generated.`;
                status.className = 'status-done';
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'status-error';
                console.error(error);
            }
        };

        function runMultipleSimulations(overrides, maxChapters, numRuns) {
            if (numRuns === 1) {
                return runSim(overrides, { maxChapters, verbose: false });
            }

            const summaries = [];
            for (let i = 0; i < numRuns; i++) {
                summaries.push(runSim(overrides, { maxChapters, verbose: false }));
            }
            return averageSummaries(summaries);
        }

        function averageSummaries(summaries) {
            const n = summaries.length;
            const first = summaries[0];

            const avg = {
                totalChapters: first.totalChapters,
                totalLoots: Math.round(summaries.reduce((s, x) => s + x.totalLoots, 0) / n),
                totalBattles: Math.round(summaries.reduce((s, x) => s + x.totalBattles, 0) / n),
                totalDefeats: Math.round(summaries.reduce((s, x) => s + x.totalDefeats, 0) / n),
                totalUnfairDefeats: Math.round(summaries.reduce((s, x) => s + x.totalUnfairDefeats, 0) / n),
                totalGoldEarned: Math.round(summaries.reduce((s, x) => s + x.totalGoldEarned, 0) / n),
                totalGoldSpent: Math.round(summaries.reduce((s, x) => s + x.totalGoldSpent, 0) / n),
                finalLampLevel: Math.round(summaries.reduce((s, x) => s + x.finalLampLevel, 0) / n),
                finalHeroPower: Math.round(summaries.reduce((s, x) => s + x.finalHeroPower, 0) / n),
                finalHeroLevel: first.finalHeroLevel,
                chapters: first.chapters.map((ch, i) => ({
                    ...ch,
                    loots: Math.round(summaries.reduce((s, x) => s + x.chapters[i].loots, 0) / n),
                    battles: Math.round(summaries.reduce((s, x) => s + x.chapters[i].battles, 0) / n),
                    defeats: Math.round(summaries.reduce((s, x) => s + x.chapters[i].defeats, 0) / n)
                })),
                stages: first.stages.map((st, i) => ({
                    ...st,
                    loots: Math.round(summaries.reduce((s, x) => s + x.stages[i].loots, 0) / n),
                    battles: Math.round(summaries.reduce((s, x) => s + x.stages[i].battles, 0) / n),
                    defeats: Math.round(summaries.reduce((s, x) => s + x.stages[i].defeats, 0) / n)
                }))
            };

            return avg;
        }

        function renderLayers(results) {
            const container = document.getElementById('layers-container');
            container.innerHTML = '';

            const baseline = results[0].summary;

            results.forEach((result, index) => {
                const layer = document.createElement('div');
                layer.className = 'layer';

                const diff = index > 0 ? calculateDiff(baseline, result.summary) : null;

                layer.innerHTML = `
                    <h3>Layer ${index}: ${result.name}</h3>
                    <div class="layer-summary">
                        <div class="summary-item">
                            <div class="summary-value">${result.summary.totalLoots}${diff ? formatDiff(diff.loots) : ''}</div>
                            <div class="summary-label">Total Loots</div>
                        </div>
                        <div class="summary-item">
                            <div class="summary-value">${result.summary.totalDefeats}${diff ? formatDiff(diff.defeats) : ''}</div>
                            <div class="summary-label">Defeats</div>
                        </div>
                        <div class="summary-item">
                            <div class="summary-value">${result.summary.finalLampLevel}</div>
                            <div class="summary-label">Lamp Level</div>
                        </div>
                        <div class="summary-item">
                            <div class="summary-value">${formatPower(result.summary.finalHeroPower)}</div>
                            <div class="summary-label">Hero Power</div>
                        </div>
                    </div>
                    <div class="charts-row">
                        <div class="chart-container">
                            <h4>Loots per Stage & Guaranteed Upgrade Interval</h4>
                            <div class="chart-scroll">
                                <canvas id="loots-stage-${index}" width="600" height="250"></canvas>
                            </div>
                        </div>
                        <div class="chart-container">
                            <h4>Loots per Chapter</h4>
                            <canvas id="loots-chapter-${index}" width="600" height="250"></canvas>
                        </div>
                    </div>
                `;
                container.appendChild(layer);

                // Render charts after DOM is updated
                const enabledFeatures = result.enabledFeatures;
                setTimeout(() => {
                    renderLootsChart(
                        document.getElementById(`loots-stage-${index}`),
                        result.summary.stages
                    );
                    renderLootsChapterChart(
                        document.getElementById(`loots-chapter-${index}`),
                        result.summary.chapters,
                        result.summary.stages,
                        { showRarity: enabledFeatures.has('rarity') }
                    );
                }, 0);
            });
        }

        function calculateDiff(baseline, current) {
            return {
                loots: current.totalLoots - baseline.totalLoots,
                defeats: current.totalDefeats - baseline.totalDefeats
            };
        }

        function formatDiff(value) {
            if (value === 0) return '';
            const cls = value > 0 ? 'diff-positive' : 'diff-negative';
            const sign = value > 0 ? '+' : '';
            return `<span class="summary-diff ${cls}">(${sign}${value})</span>`;
        }

        function formatPower(value) {
            if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
            if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
            return value.toString();
        }

        // ===== Chart Rendering Functions =====

        function renderLootsChart(canvas, stages) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const minBarWidth = 2;
            const minCanvasWidth = 600;

            const neededWidth = padding.left + padding.right + stages.length * minBarWidth;
            canvas.width = Math.max(minCanvasWidth, neededWidth);

            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const loots = stages.map(s => s.loots);
            const everyNValues = stages.map(s => s.guaranteedEveryN || 0);
            const totalDropsValues = stages.map(s => s.totalDrops || 0);
            const maxLoots = Math.max(...loots, 1);
            const maxEveryN = Math.max(...everyNValues, ...totalDropsValues, 10);

            const barWidth = width / stages.length;

            // Draw loots bars
            for (let i = 0; i < stages.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = loots[i] > 0 ? '#6bff6b' : '#333';
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            // Check if lines should be drawn (not all zeros)
            const hasEveryN = everyNValues.some(v => v > 0);
            const hasTotalDrops = totalDropsValues.some(v => v > 0);

            const yScaleEveryN = (v) => padding.top + height - (v / maxEveryN) * height;
            const xScale = (i) => padding.left + i * barWidth + barWidth / 2;

            // Fill area under EveryN line (only if has values)
            if (hasEveryN) {
                ctx.beginPath();
                ctx.moveTo(xScale(0), padding.top + height);
                for (let i = 0; i < stages.length; i++) {
                    ctx.lineTo(xScale(i), yScaleEveryN(everyNValues[i]));
                }
                ctx.lineTo(xScale(stages.length - 1), padding.top + height);
                ctx.closePath();
                ctx.fillStyle = '#ffd70022';
                ctx.fill();
            }

            // EveryN line (only if has values)
            if (hasEveryN) {
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < stages.length; i++) {
                    const x = xScale(i);
                    const y = yScaleEveryN(everyNValues[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // TotalDrops line (only if has values)
            if (hasTotalDrops) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < stages.length; i++) {
                    const x = xScale(i);
                    const y = yScaleEveryN(totalDropsValues[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Left Y label (Loots)
            ctx.fillStyle = '#6bff6b';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Right Y label (EveryN) - only if has lines
            if (hasEveryN || hasTotalDrops) {
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'left';
                ctx.fillText(maxEveryN.toString(), padding.left + width + 10, padding.top + 4);
                ctx.fillText('0', padding.left + width + 10, padding.top + height + 4);
            }

            // Legend
            ctx.font = '11px Courier New';
            let legendX = padding.left + width - 300;

            ctx.fillStyle = '#6bff6b';
            ctx.fillRect(legendX, padding.top - 20, 12, 12);
            ctx.fillText('Loots', legendX + 15, padding.top - 10);
            legendX += 80;

            if (hasEveryN) {
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(legendX, padding.top - 20, 12, 12);
                ctx.fillText('EveryN', legendX + 15, padding.top - 10);
                legendX += 80;
            }

            if (hasTotalDrops) {
                ctx.fillStyle = '#22d3ee';
                ctx.fillRect(legendX, padding.top - 20, 12, 12);
                ctx.fillText('TotalDrops', legendX + 15, padding.top - 10);
            }
        }

        function renderLootsChapterChart(canvas, chapters, stages, options = {}) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const showRarity = options.showRarity || false;

            const padding = { top: 30, right: 80, bottom: 50, left: 80 };
            const width = canvas.width - padding.left - padding.right;
            const height = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (chapters.length === 0) return;

            const loots = chapters.map(c => c.loots);
            const maxLoots = Math.max(...loots, 1);

            const barWidth = width / chapters.length;

            // Get guaranteed rarity for each chapter (only if showing)
            const chapterRarities = showRarity ? chapters.map(ch => {
                const lastStage = stages.find(s => s.chapter === ch.chapter && s.stage === 10);
                return lastStage?.guaranteedRarity || 'common';
            }) : [];

            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth;
                const barHeight = (loots[i] / maxLoots) * height;
                const y = padding.top + height - barHeight;

                ctx.fillStyle = '#6bff6b';
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
            }

            // Draw Guaranteed Rarity bar at bottom (only if showRarity)
            if (showRarity) {
                const rarityHeight = 10;
                for (let i = 0; i < chapters.length; i++) {
                    const x = padding.left + i * barWidth;
                    const rarity = chapterRarities[i];
                    ctx.fillStyle = RARITY_COLORS[rarity] || '#9ca3af';
                    ctx.fillRect(x + 2, padding.top + height + 2, barWidth - 4, rarityHeight);
                }
            }

            // X labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i < chapters.length; i++) {
                const x = padding.left + i * barWidth + barWidth / 2;
                if (chapters.length <= 30 || i % Math.ceil(chapters.length / 30) === 0) {
                    ctx.fillText(chapters[i].chapter.toString(), x, padding.top + height + 25);
                }
            }

            // Y label
            ctx.textAlign = 'right';
            ctx.fillText(maxLoots.toString(), padding.left - 10, padding.top + 4);
            ctx.fillText('0', padding.left - 10, padding.top + height + 4);

            // Legend for rarity (only when showRarity is enabled)
            if (showRarity) {
                ctx.font = '11px Courier New';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#888';
                ctx.fillText('Rarity ▼', padding.left + width - 60, padding.top - 10);
            }
        }

        // Update value displays when sliders change
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            const display = document.getElementById(slider.id + '-display');
            if (display) {
                slider.addEventListener('input', () => {
                    display.textContent = slider.value;
                });
            }
        });
    </script>
</body>
</html>
